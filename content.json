{"meta":{"title":"luheng's blog","subtitle":"编号：37927","description":null,"author":"luheng","url":"http://www.luheng.online"},"pages":[{"title":"","date":"2017-01-28T13:59:37.000Z","updated":"2018-01-08T02:10:51.647Z","comments":false,"path":"about/index.html","permalink":"http://www.luheng.online/about/index.html","excerpt":"","text":"个人简介： 计算机硬件爱好者 专业：电子信息工程 本科大三在读 关于本站 使用hexo搭建 折腾开始于2017年1月28日（大年初一） 用途：记录自己所学的知识，偶尔发发牢骚。 其他 爱好文学； 总想着走遍世界； 不怎么爱说话的少年； 对科技有着宗教般的信仰。"},{"title":"","date":"2017-01-28T15:22:14.000Z","updated":"2017-01-29T12:39:55.253Z","comments":false,"path":"categories/index.html","permalink":"http://www.luheng.online/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-01-29T11:37:44.000Z","updated":"2017-12-30T10:10:50.279Z","comments":true,"path":"guestbook/index.html","permalink":"http://www.luheng.online/guestbook/index.html","excerpt":"","text":"念念不忘，必有回响"},{"title":"","date":"2017-01-28T15:22:14.000Z","updated":"2017-12-28T03:18:48.121Z","comments":false,"path":"history/index.html","permalink":"http://www.luheng.online/history/index.html","excerpt":"","text":""},{"title":"","date":"2017-01-28T15:22:14.000Z","updated":"2017-12-30T06:02:03.171Z","comments":false,"path":"tags/index.html","permalink":"http://www.luheng.online/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-01-30T09:36:19.953Z","updated":"2018-01-30T09:36:19.928Z","comments":true,"path":"404.html","permalink":"http://www.luheng.online/404.html","excerpt":"","text":"404页面 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num 暂时未能找到您查找的页面 可能输入的网址错误或此页面不存在 秒后自动跳转到主页"}],"posts":[{"title":"FPGA.避障游戏","slug":"FPGA-避障游戏","date":"2018-01-06T04:21:12.000Z","updated":"2018-01-08T02:38:07.559Z","comments":true,"path":"2018/01/06/FPGA-避障游戏/","link":"","permalink":"http://www.luheng.online/2018/01/06/FPGA-避障游戏/","excerpt":"这是一个使用FPGA制作的小游戏，知识主要是VGA的使用和关于游戏的逻辑处理。在这篇中将会讲诉VGA的显示原理和使用，还有一些关于键盘的消抖的小知识。","text":"这是一个使用FPGA制作的小游戏，知识主要是VGA的使用和关于游戏的逻辑处理。在这篇中将会讲诉VGA的显示原理和使用，还有一些关于键盘的消抖的小知识。 游戏介绍游戏规则 利用FPGA，以640*480的分辨率使用VGA显示，玩家利用按键操作位于屏幕左侧的方块移动，来躲避从屏幕右侧向左边移动的留有一定间隙的障碍物。 游戏要求 画面及操作尽量连续，游戏结束时玩家操作的物体变成红色，按下重新开始后复位游戏，随着时间变长加速以提高难度。 基本上整个游戏就像是以前的飞机小游戏，为了增加可玩性，我将游戏设置为方块自动降落，外部只有一个按键，实现方块的向上移动，去躲避向左移动的挡板。 设计分析模块设定首先游戏要有显示画面，所以少不了vga的显示模块；其次是要控制方块的移动，需要键盘的输入模块，最后是关于游戏的逻辑控制，这需要一个控制模块。 那这些模块都需要什么哪些信号呢？接着分析下。 键盘模块键盘模块作为整个避障游戏系统的输入，它主要是为其他模块提供信号，对信号的处理并不多。 输入 功能描述 clk 时钟 reset 复位 up 使方块上升 输出 功能描述 up_key_press 方块上升信号 down_key_press 方块下降信号 前面说了，为了增加可玩性，所以我在系统内部设置了让方块自动下落，所以输入只有up,但是输出时会有down_key_press。 关于键盘的输入输出就是如此，至于模块如何实现这些功能，分析阶段不解释，在下文中会陆陆续续讲解。 VGA模块vga模块的功能就是将数据显示，原理在下文我会讲解，弄懂它的时序后，问题不会太大，一开始可以尝试先显示个彩条之类的，测试下，找下感觉。 输入 功能描述 clk 时钟 reset 复位 输出 功能描述 dat_act 数据有效标志位 hc 行扫描计数器 vc 列扫描计数器 hsync 行同步信号 vsync 场同步信号 控制模块控制模块这个部分是整个游戏的规则的设定，可以说，游戏怎么玩完全由这个模块决定，根据游戏的描述和要求，我们是要控制一个方块去躲避不断向左移动的挡板，所以这个挡板和方块怎么“弄出来”就是关键了。 怎么弄出来呢? 首先要有个概念，我们所看到的VGA图像都是一个个像素点组成，使用640*480 的显示模式，这个规定相当于为我们规定了横纵坐标的定义域，在这个二维屏幕上。方块和遮挡板就可以用数学式子“画”出来，例如边长为两个像素点一个方块就是：0&lt;x&lt;2 ,0&lt;y&lt;2。 友情提醒：FPAG中能用正数就尽量不要用负数，数字在FPGA中是用补码表示的，负数的补码往往与我们的思维逻辑有点出入，容易导致出错。 输入 功能描述 clk 时钟 reset 复位 up_key_press 方块上升信号 down_key_press 方块的下降信号 hc 行扫描计数器 vc 列扫描计数器 dat_act 数据有效标志位（用于消隐） 输出 功能描述 disp_RGB 显示所需的数据 总体的设计图 方案设计键盘模块键盘模块的要点在于消抖，和控制方块移动。 消抖无论是什么器件，键盘的消抖都是老套路，分为硬件消抖和软件消抖，硬件消抖如使用RS触发器实现或者是加电容实现，一般是制作板子的时候考虑加上去的，平时我们使用现成的板子，大多数都是使用软件消抖。 键盘产生抖动是机械特性，在我们按下按键是接触点的电压波形大致如下图： 从图可以看出，按下时会有一段上下波动的波形，松开时也有一段。 软件消抖常用的方法是延时，作用就是避开这一段“抖动”的波形，达到消抖的目的。 12345678910if(counter &lt;= T) //按的时间不够长 begin counter = counter + 1'b1; up_key_press &lt;= 0; endelse //按下足够久了，认为是真的按下 begin counter &lt;= 0; up_key_press &lt;= 1; end 硬件消抖这里也稍微拓展下。 RS触发器实现 图中两个“与非”门构成一个RS触发器。当按键未按下时，输出为0;当键按下时，输出为1。此时即使用按键的机械性能，使按键因弹性抖动而产生瞬时断开（抖动跳开B），只要按键不返回原始状态A，双稳态电路的状态不改变，输出保持为0，不会产生抖动的波形。也就是说，即使B点的电压波形是抖动的，但经双稳态电路之后，其输出为正规的矩形波。这一点通过分析RS触发器的工作过程很容易得到验证。 至于其他的硬件消抖电路，如：用电容构成的积分电路实现，采用D触发器实现，这里不再拓展，如有兴趣，可自行查阅资料。 控制移动这个功能的实现，应该说不难。知道要改变哪个参数能使它移动，改变它就可以实现了，在这个游戏系统中，控制方块上下移动是改变 move_y 这个参数，左右移动是改变move_x，不过在后面测试游戏时，我觉得左右移动没有必要加上去，就把它去了,具体的操作看代码吧。 VGA模块实现这个游戏，我认为最重要的知识就是VGA的显示原理了。数据怎么显示在屏幕的？640和480指的又是什么？我们先看它的原理。 VGA原理VGA从扫描方式上分行扫描和场扫描两种，扫描就是一个电子枪（CRT），啾啾啾的扫，水平方向叫行扫描，垂直方向叫场扫描，这个电子枪它又可发出三种颜色光，分别是R(红色)，G(绿色)，B(蓝色)，光的三原色都有，原则上三原色按照比例不同搭配，那你想要什么颜色就可以给你什么颜色，但实际上呢，VGA中红，绿，蓝的输入线分别是3,3,2根；也就是说红色有2^3=8种，同理，绿色八种，蓝色四种，相互搭配，便有8 X 8 X 4=256种搭配，也就是VGA能显示256种颜色。 扫描过程是怎样的？ 以行扫描为例: 从图可以看出，电子枪从左往右扫射一行回头再到下一行，直至最后完成一帧画面，又重头开始。那什么时候掉头，什么时候算是完成一帧画面，这就有个区域了，区域怎么定，是由显示模式决定的，看下图。 我们可以看到有多种显示模式，不同的显示模式所需的时钟频率可是不一样的，如果细心查看，就会注意到，行时序的c区和列时序的q区恰好是640和480这两个熟悉的数字，其实这就是显示时序段的范围。 VGA中定义行时序和场时序都需要同步脉冲（Sync a）、显示后沿（Back porch b）、显示时序段（Display interval c）和显示前沿（Front porch d）四部分。只有在显示时序段，也就是C区才可以信号显示出来，其他区域，你就算给VGA信号，你也看不到。 行时序 场时序 那么我们怎么知道，电子枪（CRT）有没有扫描到显示时序段呢？方法是加入行同步计数器和列同步计数器用，反正时序是固定的，行同步计数器是扫一下计数器加一，列计数器是一行扫完计数器加一，两者都扫到C区了，也就是计数器都达到一定数值（a区长度+B区长度），表明屏幕可以显示信号，我就给信号，要黑色，rgb全给0，要白色，全给1，反正就是给信号，这和在坐标轴上画图的感觉是一样一样的。 控制模块控制模块就像这个游戏系统的控制中心一般，制定了关于这个游戏的一切规则。 主要有那么几个要点: 将键盘的长脉冲变为一个个冲击信号，不然以FPGA本身的频率，按一下，移动得太快，方块就“上天” 了,障碍物移动也会快到你看不到。 “画”方块和障碍物（挡板），并设定参数让给它们可以移动。 由于挡板的垂直方向出现的位置要有随机性，所以需要产生随机数。 设置游戏失败的情况，方块与挡板“撞上”这个时机的设置必须是程序完成。 长脉冲变多个短脉冲这不难想也不难实现，就是计数器加到一定程度变为标志位变为1，然后计数器清零，标志位也变为0，一定时间内要短脉冲多点，计数器的计数值就小点，反之，大一点。 123456789101112131415161718192021222324252627282930313233//// 板块移动速度控制 ////reg move;reg [32:0]counter;reg [30:0]T_move;always@(posedge clk,negedge reset)begin if(!reset) begin T_move = 30'd10_000_00; counter &lt;= 0; move &lt;=0; end else begin if(counter &gt;= T_move) begin move = 1; if(T_move == 100_000) T_move &lt;=T_move; else T_move = T_move-10; counter = 0; end else begin move = 0; if(!stop) counter= counter + 1; else counter = 0; end endend “画”方块和挡板关于如何“画”，前面举过画方块的例子，就是把行列计数器当做 x,y。x给个区域，y给个区域，再给个颜色，就画出来了。至于移动呢，移动就代表着位置是个变量，设定一个x,y都是变量的点，然后以这个点为中心画出你要的方块或者挡板，改变这个点的x,y便是将它移动。 以挡板从右向左移动为例： 产生随机数产生伪随机数的方法最常见的是利用一种线性反馈移位寄存器(LFSR),它是由n个D触发器和若干个异或门组成的，如下图： 实际上这个有规律可循的，只不过D触发器一多，显得很乱，很像随机产生的样子，但确实不是真正意义上的随机数，是个伪随机数，但在这里使用足够了的。 但这种方法也有bug,就是高位它不容易变化的时候，挡板垂直方向就不够分散，举个例子，以8个D触发器组成的为例，数字范围从0~1111_1111,如果高位变化不大，如从1110_0000变成1110_0101,高位不怎么变化的话，整个数字大小实际上就是改变一点点，图像表现为前后两个挡板垂直位置上相差几个像素点，这就显得过于集中，而且这种办法无法生成 0 这个数字。 为了将挡板”离散一点”，我就将竖直方向的长减去挡板的长度后得到的空隙分段化，分为8段，这样挡板之间的距离要么相等，不然都会有一段距离，显得离散些。怎么实现呢？ 每个D触发器都存有一个数字，我从中随机抽取三个数字，做一个case语句的选择，8段8种情况选择。这样随机性增加，挡板也更离散。 123456789101112131415161718192021222324252627282930313233343536/////// 随机数 ////////// reg [7:0] rand_num;parameter seed = 8'b1111_1111;always@(posedge clk or negedge reset)begin if(!reset) rand_num &lt;= seed; else begin rand_num[0] &lt;= rand_num[1] ; rand_num[1] &lt;= rand_num[2] + rand_num[7]; rand_num[2] &lt;= rand_num[3] + rand_num[7]; rand_num[3] &lt;= rand_num[4] ; rand_num[4] &lt;= rand_num[5] + rand_num[7]; rand_num[5] &lt;= rand_num[6] + rand_num[7]; rand_num[6] &lt;= rand_num[7] ; rand_num[7] &lt;= rand_num[0] + rand_num[7]; endendwire [2:0]choose;reg [8:0]type;assign choose = &#123;rand_num[3],rand_num[6],rand_num[2]&#125;;always@(posedge clk )begin case(choose) 0:type = 0; 1:type = 40; 2:type = 80; 3:type = 120; 4:type = 160; 5:type = 200; 6:type = 240; 7:type = 280; endcaseend//////////////////////////////////////////////////////// 游戏失败设置游戏失败是撞上了，那 撞上 在数学上表示是什么呢？ 答案是方块和挡板的坐标有交叉。 方块和挡板之间都有坐标的区域，只要找到它们会交叉的情况，就说明这个时候是撞上了。原理就是如此，具体的可以自己动笔算下。 友情提醒：加减时注意尽量不要出现负数的情况，因为 数字用补码表示的原因，在FPGA中，直接比较 ，-1=ffff_ffff 可是大于0的。 12345678910wire die1,die2,die3,die4;//游戏失败定义，方块与挡板\"碰撞\"//失败情况讨论，共设置四块挡板，四种情况assign die1=((rand&lt;move_y + border)&amp;&amp;(move_y &lt; rand+long)&amp;&amp;(push &lt; move_x+border) &amp;&amp; (move_x &lt; push + ban ));assign die2=((rand1&lt;move_y + border)&amp;&amp;(move_y &lt; rand1+long)&amp;&amp;(push1 &lt; move_x+border) &amp;&amp; (move_x &lt; push1 + ban ));assign die3=((rand2&lt;move_y + border)&amp;&amp;(move_y &lt; rand2+long)&amp;&amp;(push2 &lt; move_x+border) &amp;&amp; (move_x &lt; push2 + ban ));assign die4=((rand3&lt;move_y + border)&amp;&amp;(move_y &lt; rand3+long)&amp;&amp;(push3 &lt; move_x+border) &amp;&amp; (move_x &lt; push3 + ban ));wire false;assign false = die1||die2||die3||die4; 代码展示键盘模块.testButton { color:black;font-size:12px;padding-top:10px;padding-bottom:10px;padding-left:25px;padding-right:25px;border-width:;border-color:white;border-style:;border-radius:10px;background-color:#f3f3f3;}.testButton:hover{color:white;background-color:#0684bd;border-color:#87daff;} 点击显\\隐代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253module key(clk,reset,up,up_key_press,down_key_press);input clk;input reset;input up;output reg up_key_press;output reg down_key_press;parameter T = 30'd10_000_00; //控制方块移动速度////////// up 按键 /////////////reg [30:0] counter;reg [30:0] counter2;always@(posedge clk,negedge reset )begin if(!reset) begin counter &lt;= 0; counter2 &lt;= 0; up_key_press &lt;= 0; down_key_press &lt;= 0; end else begin if(up) begin if(counter &lt;= T) begin counter = counter + 1'b1; up_key_press &lt;= 0; end else begin counter &lt;= 0; up_key_press &lt;= 1; end end else //下降按钮 begin if(counter2 &lt;= T) begin counter2 = counter2 + 1'b1; down_key_press &lt;= 0; end else begin counter2 &lt;= 0; down_key_press &lt;= 1; end end endendendmodule VGA模块点击显\\隐代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980module vga( clk,reset,hsync, vsync,hc,vc,dat_act); input clk; //系统输入时钟 100MHz input reset; output hsync; //VGA 行同步信号 output vsync; //VGA 场同步信号 output dat_act; output [9:0]hc ,vc; //转成640*480的模式 reg [9:0] hcount; //VGA 行扫描计数器 reg [9:0] vcount; //VGA 场扫描计数器 reg flag; wire hcount_ov; wire vcount_ov; wire hsync; wire vsync; reg vga_clk=0; reg cnt_clk=0; //分频计数 //VGA 行、场扫描时序参数表 parameter hsync_end = 10'd95, hdat_begin = 10'd143, hdat_end = 10'd783, hpixel_end = 10'd799, vsync_end = 10'd1, vdat_begin = 10'd34, vdat_end = 10'd514, vline_end = 10'd524; //分频 always @(posedge clk) begin if(cnt_clk == 1) begin vga_clk &lt;= ~vga_clk; cnt_clk &lt;= 0; end else cnt_clk &lt;= cnt_clk +1; end //************************VGA 驱动部分*******************************//行扫描 always @(posedge vga_clk) begin if (hcount_ov) hcount &lt;= 10'd0; else hcount &lt;= hcount + 10'd1; end assign hcount_ov = (hcount == hpixel_end); //场扫描 always @(posedge vga_clk) begin if (hcount_ov) begin if (vcount_ov) vcount &lt;= 10'd0; else vcount &lt;= vcount + 10'd1; end end assign vcount_ov = (vcount == vline_end); //数据、同步信号输 assign dat_act = ((hcount &gt;= hdat_begin) &amp;&amp; (hcount &lt; hdat_end))&amp;&amp; ((vcount &gt;= vdat_begin) &amp;&amp; (vcount &lt; vdat_end)); assign hsync = (hcount &gt; hsync_end); assign vsync = (vcount &gt; vsync_end); //计数器转成640 x 480的样式，方便开发 assign hc = hcount - hdat_begin; assign vc = vcount - vdat_begin; endmodule 控制模块点击显\\隐代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264module control( clk,reset, disp_RGB,hc,vc,dat_act,up_key_press,down_key_press ); input clk; //系统输入时钟 100MHz input reset; input dat_act; input [9:0]hc,vc; input up_key_press; input down_key_press; output [2:0]disp_RGB; //VGA 数据输出 reg [2:0]data; reg vga_clk=0; reg cnt_clk=0; //分频计数 //分频 always @(posedge clk) begin if(cnt_clk == 1) begin vga_clk &lt;= ~vga_clk; cnt_clk &lt;= 0; end else cnt_clk &lt;= cnt_clk +1; end //定义正方形小块的边长 parameter border = 40; //定义挡板的宽度 parameter ban = 20; //定义挡板的长度 parameter long = 200; //定义挡板的间隔 parameter magin = 160; //VGA扫描，画出挡板和方块，并设置挡板移动的移动变量push reg [10:0] push,push1,push2,push3; reg stop;//用于停止游戏 //小方块移动数据存储器 parameter move_x = 50; //方块的初始位置 reg [9:0]move_y; /////// 随机数 ////////// reg [7:0] rand_num;parameter seed = 8'b1111_1111;always@(posedge clk or negedge reset)begin if(!reset) rand_num &lt;= seed; else begin rand_num[0] &lt;= rand_num[1] ; rand_num[1] &lt;= rand_num[2] + rand_num[7]; rand_num[2] &lt;= rand_num[3] + rand_num[7]; rand_num[3] &lt;= rand_num[4] ; rand_num[4] &lt;= rand_num[5] + rand_num[7]; rand_num[5] &lt;= rand_num[6] + rand_num[7]; rand_num[6] &lt;= rand_num[7] ; rand_num[7] &lt;= rand_num[0] + rand_num[7]; endendwire [2:0]choose;reg [8:0]type;assign choose = &#123;rand_num[3],rand_num[6],rand_num[2]&#125;;always@(posedge clk )begin case(choose) 0:type = 0; 1:type = 40; 2:type = 80; 3:type = 120; 4:type = 160; 5:type = 200; 6:type = 240; 7:type = 280; default: type = 280; endcaseend//////////////////////////////////////////////////////////// 板块移动速度控制 ////reg move;reg [32:0]counter;reg [30:0]T_move;always@(posedge clk,negedge reset)begin if(!reset) begin T_move = 30'd10_000_00; counter &lt;= 0; move &lt;=0; end else begin if(counter &gt;= T_move) begin move = 1; if(T_move == 100_000) T_move &lt;=T_move; else T_move = T_move-10; counter = 0; end else begin move = 0; if(!stop) counter= counter + 1; else counter = 0; end endendreg [8:0]rand,rand1,rand2,rand3;always@(posedge clk or negedge reset)begin if (!reset) begin push&lt;=640; //初始位置设定 push1 &lt;= 640+ magin; push2 &lt;= 640 + magin + magin; push3 &lt;= 640 + magin + magin + magin; endelse if (move) begin if(push == 0) begin push &lt;= 640; rand &lt;=type; //第一块板子的位置设定 end else begin push &lt;= push-1'b1; end if(push1 == 0) begin push1 &lt;= 640; rand1 &lt;=type; //第二块板子的位置设定 end else begin push1 &lt;= push1-1'b1; end if(push2 == 0) begin push2 &lt;= 640; rand2 &lt;=type; //第三块板子的位置设定 end else begin push2&lt;= push2-1'b1; end if(push3 == 0) begin push3 &lt;= 640; rand3 &lt;=type; //第四块板子的位置设定 end else begin push3 &lt;= push3-1'b1; end end else begin push &lt;= push; push1 &lt;= push1; push2 &lt;= push2; push3 &lt;= push3; endendwire die1,die2,die3,die4;//游戏失败定义，方块与挡板\"碰撞\"//失败情况讨论，共设置四块挡板，四种情况assign die1=((rand&lt;move_y + border)&amp;&amp;(move_y &lt; rand+long)&amp;&amp;(push &lt; move_x+border) &amp;&amp; (move_x &lt; push + ban ));assign die2=((rand1&lt;move_y + border)&amp;&amp;(move_y &lt; rand1+long)&amp;&amp;(push1 &lt; move_x+border) &amp;&amp; (move_x &lt; push1 + ban ));assign die3=((rand2&lt;move_y + border)&amp;&amp;(move_y &lt; rand2+long)&amp;&amp;(push2 &lt; move_x+border) &amp;&amp; (move_x &lt; push2 + ban ));assign die4=((rand3&lt;move_y + border)&amp;&amp;(move_y &lt; rand3+long)&amp;&amp;(push3 &lt; move_x+border) &amp;&amp; (move_x &lt; push3 + ban ));wire false;assign false = die1||die2||die3||die4;//描述运动，“画图”always@(posedge vga_clk,negedge reset)begin if(!reset) begin data &lt;= 0; stop &lt;= 0; end else begin if (hc&gt;move_x &amp;&amp;(hc&lt;(move_x+border)&amp;&amp;(vc&gt;move_y)&amp;&amp;(vc&lt;move_y+border))) //小方块 begin if(!false) begin data &lt;= 3'h3; //黄色 stop &lt;= 0; end else begin data &lt;= 3'h1; //红色 stop &lt;=1; end end else if ((hc&gt;push) &amp;&amp; (hc&lt;=push+ban) &amp;&amp; (vc&gt;=rand) &amp;&amp; (vc&lt;=rand+long)) begin data &lt;= 3'h2; //第一根横条 end else if ((hc&gt;push1) &amp;&amp; (hc&lt;=push1+ban) &amp;&amp; (vc&gt;=rand1) &amp;&amp; (vc&lt;=rand1+long)) begin data &lt;= 3'h2; //第二根横条 end else if ((hc&gt;push2) &amp;&amp; (hc&lt;=push2+ban) &amp;&amp; (vc&gt;=rand2) &amp;&amp; (vc&lt;=rand2+long)) begin data &lt;= 3'h2; //第三根横条 end else if ((hc&gt;push3) &amp;&amp; (hc&lt;=push3+ban) &amp;&amp; (vc&gt;=rand3) &amp;&amp; (vc&lt;=rand3+long)) begin data &lt;= 3'h2; //第四根横条 end else data &lt;= 0; endend/////// 方块移动控制 //////////// always@(posedge clk or negedge reset) begin if (!reset) begin move_y &lt;= 240; end else if (up_key_press) begin if(move_y == 0) begin move_y &lt;= move_y; end else begin move_y &lt;= move_y-1'b1; end end else if (down_key_press) begin if(move_y&gt;440) begin move_y &lt;= move_y; end else begin move_y &lt;= move_y+1'b1; end end end// 信号输出assign disp_RGB = (dat_act) ? data : 3'h00;endmodule TOP模块点击显\\隐代码 12345678910111213141516171819module top(clk,reset,up,hsync,vsync,disp_RGB);input clk;input reset;input up;output hsync; //VGA 行同步信号output vsync; //VGA 场同步信号output [2:0]disp_RGB; //VGA 数据输出wire dat_act;wire up_key_press;wire down_key_press;wire [9:0]hc,vc;key U1(clk,reset,up,up_key_press,down_key_press);control U2( clk,reset, disp_RGB,hc,vc,dat_act,up_key_press,down_key_press );vga U3( clk,reset,hsync, vsync,hc,vc,dat_act);endmodule 写在后面的话关于这个小游戏的讲解就到这里，有任何疑问可以在评论处指出或者联系我，我会及时更新，文章若有错误，恳请读者在评论区指出斧正，我会修改。 欢迎大家在评论区与我交流，学习。","categories":[{"name":"搞硬件","slug":"搞硬件","permalink":"http://www.luheng.online/categories/搞硬件/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://www.luheng.online/tags/FPGA/"}]},{"title":"FPGA.数字闹钟","slug":"FPGA-数字闹钟","date":"2017-11-22T13:28:09.000Z","updated":"2018-01-10T09:26:14.394Z","comments":true,"path":"2017/11/22/FPGA-数字闹钟/","link":"","permalink":"http://www.luheng.online/2017/11/22/FPGA-数字闹钟/","excerpt":"用FPGA设计一个数字闹钟应该说是一个比较综合的小系统，包含了按键、数码管、状态机等内容，本文主要是讲述三键输入的数字闹钟总体的设计，整个作品和小时候两三块一个的电子手表十分类似。下面具体讲解…","text":"用FPGA设计一个数字闹钟应该说是一个比较综合的小系统，包含了按键、数码管、状态机等内容，本文主要是讲述三键输入的数字闹钟总体的设计，整个作品和小时候两三块一个的电子手表十分类似。下面具体讲解… 功能描述 1 用四个数码管正常显示时、分高低位，实现正常显示时间。2 具备调分调时功能3 闹钟功能 功能并不复杂，我们现在来分析一下需要哪些模块。首先是时钟功能，正常显示时间肯定是必须的，为实现这一可以设计一个60进制计数器和一个24进制计数器，当然也可以根据逻辑直接书写出来，但无论是什么办法，这肯定需要一个模块来实现它。 第二就是调分调时了，说白了就是置数，要置数，那么就必须有一个区域去控制数据，也需要一个地方存储数据，然后将置数的数据传给时钟，所以它应该与键盘的联系，内部有存储器。 第三是闹钟，闹钟不难想，比较器，我设定闹钟时间，然后与时钟的时间比较，如果两者相同，输出闹钟信号，就是如此。 最后的便是显示电路，主要是数码管的显示原理，驱动数码管显示时间。 就是这几样部分，貌似这么一说，确实没有什么东西，一个系统就是需要输入和输出相互协调好，这里面的逻辑必须是相互对应的，不出矛盾，个人认为，这是设计的难度所在。 整体设计图 模块讲解键盘模块（key） 输入 功能说明 输出 功能说明 add_in 加 c_add 时钟加 aub_in 减 c_sub 时钟减 model_in 模式控制端 a_hour 调闹钟小时 clk 时钟 a_minute 调闹钟分钟 rst_n 复位 cnt_control 计数器开关 Display_Model 显示控制 Time_model 调时钟转换信号 细节讲解 model:模式的选择寄存器 整个闹钟系统我设置为五个模式，所以model需要是三位的[2:0]00:时钟正常走时01：时钟调分模式，该模式下时钟的计数器停止，时钟是不走的，同时显示模式也会转到调时钟模式。10：时钟调时模式，与调分模式类似。11：闹钟调分设置模式，此时时钟走时，显示模式为闹钟模式。 100：闹钟调时模式，与调分时类似。 cnt_control:计数器开关 正常走时和调闹钟模式下，计数器开，cnt_control = 0;当进入调分和调时模式，计数器关闭，cnt_control = 1。 Time_Model:调时钟转换信号 这个是连接时钟模块（clock）的，是调分模式和调时模式的切换信号。 Display_Model:显示控制 正常走时，进入调分和调时模式时，停止走时，整个过程我设置为同一种显示模式；闹钟模式下，显示模式转换；所以一共是两种模式，一根线足以。 代码展示.testButton { color:black;font-size:12px;padding-top:10px;padding-bottom:10px;padding-left:25px;padding-right:25px;border-width:;border-color:white;border-style:;border-radius:10px;background-color:#f3f3f3;}.testButton:hover{color:white;background-color:#0684bd;border-color:#87daff;} 点击显\\隐代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340module key( input clk, input rst_n, input add_in,//增加按钮 input sub_in,//减去按钮 input model_in,//模式选择 output reg Display_Model, //时钟与闹钟显示选择，0 代表时钟，1代表闹钟 output reg cnt_control, //控制定时器 output reg [2:0]Time_model, output reg c_add, //控制时钟 加 output reg c_sub, //控制时钟 减 output reg a_add, //控制闹钟 加 output reg a_sub //控制闹钟 减 ); /************************************/parameter T40MS = 20'd40_000;parameter T1S = 30'd1_000_000;/************************************//// add_in 按键 /////reg add;reg [19:0]cnt_a;reg [1:0]a; always @(posedge clk or negedge rst_n) begin if(!rst_n) begin cnt_a &lt;= 0; a &lt;= 0; add &lt;= 1; end else begin case(a) 0:begin if(cnt_a &lt; T40MS) // 按下时间大于40MS 认为有效 begin if(!add_in) cnt_a = cnt_a+1'b1; else cnt_a = 0; end else //counter&gt; 40MS ，说明确实按键是按下了 begin add = 0; // 给冲击信号 ，0~1 是上升沿 a = 1; //确定按键按下，转到状态 1 cnt_a = 0; //计数器清零 end end 1:begin add = 1; //产生尖脉冲 if(cnt_a &lt; T40MS) // 按下时间大于40MS 松开有效 begin if(add_in) cnt_a = cnt_a+1'b1; else cnt_a = 0; end else begin a = 0; // 若松开，回到状态 0 ，等待下次按键到来 cnt_a = 0; end end default : a = 1; endcase end end///////////////////////////////////////////////////////////// sub_in 按键 ///reg sub;reg [19:0]cnt_s;reg [1:0]s; always @(posedge clk or negedge rst_n) begin if(!rst_n) begin cnt_s &lt;= 0; s &lt;= 0; sub &lt;= 1; end else begin case(s) 0:begin if(cnt_s &lt; T40MS) // 按下时间大于40MS 认为有效 begin if(!sub_in) cnt_s = cnt_s+1'b1; else cnt_s = 0; end else //counter&gt; 40MS ，说明确实按键是按下了 begin sub = 0; // 给冲击信号 ，0~1 是上升沿 s = 1; //确定按键按下，转到状态 1 cnt_s = 0; //计数器清零 end end 1:begin sub = 1; //产生尖脉冲 if(cnt_s &lt; T40MS) // 按下时间大于40MS 松开有效 begin if(sub_in) cnt_s = cnt_s+1'b1; else cnt_s = 0; end else begin s = 0; // 若松开，回到状态 0 ，等待下次按键到来 cnt_s = 0; end end default : s = 1; endcase end end//////////////////////////////////////////////////////////// /// model_in 按键 ///reg model;reg [19:0]cnt_m;reg [1:0]m; always @(posedge clk or negedge rst_n) begin if(!rst_n) begin cnt_m &lt;= 0; m &lt;= 0; model &lt;= 1; end else begin case(m) 0:begin if(cnt_m &lt; T40MS) // 按下时间大于40MS 认为有效 begin if(!model_in) cnt_m = cnt_m+1'b1; else cnt_m = 0; end else //counter&gt; 40MS ，说明确实按键是按下了 begin model = 0; // 给冲击信号 ，0~1 是上升沿 m = 1; //确定按键按下，转到状态 1 cnt_m = 0; //计数器清零 end end 1:begin model = 1; //产生尖脉冲 if(cnt_m &lt; T40MS) // 按下时间大于40MS 松开有效 begin if(model_in) cnt_m = cnt_m+1'b1; else cnt_m = 0; end else begin m = 0; // 若松开，回到状态 0 ，等待下次按键到来 cnt_m = 0; end end default : m = 1; endcase end end/////////////////////////////////////////////////////////////************************************************/reg [2:0]type;//00：时钟正常跑模式//01：时钟调分模式,在该模式时间计数器停止计数//10: 时钟调时模式，在该模式时间计数器停止计数//11：闹钟调分模式，在该模式时间计数器正常计数//100：闹钟调时模式，在该模式时间计数器正常计数/************************************************/always @(posedge clk or negedge rst_n) if(!rst_n) begin Display_Model &lt;= 1'b0; a_add &lt;= 1'b0; a_sub &lt;= 1'b0; c_add &lt;= 1'b0; c_sub &lt;= 1'b0; Time_model &lt;= 3'b000; type &lt;= 3'b000; cnt_control &lt;= 1'b1;//启动计数 end else begin if(!model) begin if(type == 3'b100) type = 3'b000; else begin type = type + 1'b1; end end case(type) //时钟正常开始跑 3'b000: begin Time_model &lt;= 3'b000; cnt_control &lt;= 1'b1;//启动计数 Display_Model &lt;= 1'b0; a_add &lt;= 1'b0; a_sub &lt;= 1'b0; c_add &lt;= 1'b0; c_sub &lt;= 1'b0; end //调分模式 3'b001: begin cnt_control &lt;= 1'b0; //关闭计数 Time_model &lt;= 3'b001; Display_Model &lt;= 1'b0; if(!add)//加 begin c_add &lt;=1'b1 ; end else begin c_add &lt;= 1'b0; end if(!sub)//减 begin c_sub &lt;= 1'b1; end else begin c_sub &lt;= 1'b0; end end //调时模式 3'b010: begin cnt_control &lt;= 1'b0;//关闭计数 Time_model &lt;= 2'b010; Display_Model &lt;= 1'b0; if(!add)//加 begin c_add &lt;=1'b1 ; end else begin c_add &lt;= 1'b0; end if(!sub)//减 begin c_sub &lt;= 1'b1; end else begin c_sub &lt;= 1'b0; end end //调分模式 3'b011: begin cnt_control &lt;= 1'b1; //kaijishu Time_model &lt;= 3'b011; Display_Model &lt;= 1'b1; if(!add)//加 begin a_add &lt;=1'b1 ; end else begin a_add &lt;= 1'b0; end if(!sub)//减 begin a_sub &lt;= 1'b1; end else begin a_sub &lt;= 1'b0; end end //调时模式 3'b100: begin cnt_control &lt;= 1'b1;//关闭计数 Time_model &lt;= 3'b100; Display_Model &lt;= 1'b1; if(!add)//加 begin a_add &lt;=1'b1 ; end else begin a_add &lt;= 1'b0; end if(!sub)//减 begin a_sub &lt;= 1'b1; end else begin a_sub &lt;= 1'b0; end end default:type &lt;= 3'b000; endcase endendmodule 时钟模块（clock） 输入 功能说明 输出 功能说明 c_add 加 hour_h 小时高位 c_sub 减 hour_l 小时低位 Time_model 模式控制端 minute_h 分钟高位 cot_control 计数器开关 minute_l 分钟低位 clk 时钟 rst_n 复位 细节讲解时钟模块的输入都是来自键盘模块，所以输入不多说了，提一点，我的板子上的输入的时钟（clk），用的是50MHz晶振,而时钟是1Hz,也就是一秒走一下，所以内部必须分频，代码里注意看一下，我为了方便调试，分频并不是分频到1Hz，如果你有需要用到，修改里面的参数就好。 模块输出 模块的输出就是时钟的数据，是传给显示模块去驱动数码管显示的。小时高位，0~2，三种情况，两根线[1:0]小时低位，0~0，十种情况，四根线[3:0]分钟高位，0~5，六种情况，三根线[2:0]分钟低位，0~9，十种情况，四根线[3:0] 代码展示点击显\\隐代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173module clock( input clk, input rst_n, input cnt_control, //控制定时器 ,1启动 ，0停止 input c_add, //控制 加 input c_sub, //控制 减 input [2:0]Time_model, output [1:0]hour_h, //小时 十位 output [3:0]hour_l, //小时 个位 output [2:0]minute_h, //分钟 十位 output [3:0]minute_l //分钟 个位 ); parameter S= 100000000; parameter M=60; /*********************************************************/ //1S计数器 reg [31:0] cnt1s; always @(posedge clk or negedge rst_n) if(!rst_n) cnt1s &lt;= 15'd0; else if((cnt1s == S) || (!cnt_control)) cnt1s &lt;= 15'd0; else if(cnt_control) cnt1s &lt;= cnt1s + 1'b1; /*********************************************************/ /////////////////////////////////////////////////////////// // 功能控制 // ////////////////////////////////////////////////////////// reg [1:0]flag;//用来标志reg1是否到了2，到了2,reg2只能加到4 reg [1:0] reg1;//时的第一位：0~2 reg [3:0] reg2; //时的第二位：当第一位为0和1时，可以是0~9,当第一位为2时，只能是0~9, reg [2:0] reg3;//分的第一位：只能是0~5 reg [3:0] reg4;//分的第二位：是0~9 always @(posedge clk or negedge rst_n) begin if(!rst_n) begin reg1 &lt;= 2'd0; //小时 高位 reg2 &lt;= 4'd0; //小时 低位 reg3 &lt;= 3'd0; //分钟 高位 reg4 &lt;= 4'd0; //分钟 低位 flag &lt;= 2'd0; end else case(Time_model) //时钟正常开始跑 3'b000: begin if(cnt1s == S) //一分钟到了 begin reg4 &lt;= reg4 + 1'b1; if(reg4 == 4'd9) begin reg4 &lt;= 4'd0; reg3 &lt;= reg3 + 1'b1; if(reg3 == 3'd5) begin reg3 &lt;= 3'd0; if(reg1 == 2'd2) begin reg2 &lt;= reg2 + 1'b1; if(reg2 == 4'd3) begin reg2 &lt;= 4'd0; reg1 &lt;= 2'd0; end end else begin reg2 &lt;= reg2 + 1'b1; if(reg2 == 4'd9) begin reg2 &lt;= 4'd0; reg1 &lt;= reg1 + 1'b1; end end end end end end //调分模式 3'b001: begin if(c_add)//加 begin reg4 &lt;= reg4 + 1'b1; if(reg4 == 4'd9) begin reg4 &lt;= 4'd0; reg3 &lt;= reg3 + 1'b1; if(reg3 &gt; 3'd5) reg3 &lt;= 3'd0; end end else if(c_sub)//减 begin reg4 &lt;= reg4 - 1'b1; if(reg4 == 4'd0) begin reg4 &lt;= 4'd9; reg3 &lt;= reg3 - 3'd1; if(reg3 == 3'd0) reg3 &lt;= 3'd5; end end end //调时模式 3'b010: begin if(c_add)//加 begin if(flag == 2'd2) begin reg2 &lt;= reg2 + 1'b1; if(reg2 &gt;= 4'd3) begin reg2 &lt;= 4'd0; reg1 &lt;= 2'd0; flag &lt;= 2'd0; end end else begin reg2 &lt;= reg2 + 1'b1; if(reg2 == 4'd9) begin flag &lt;= flag + 1'b1; reg2 &lt;= 4'd0; reg1 &lt;= reg1 + 1'b1; end end end else if(c_sub)//减 begin if(flag == 2'd0) begin reg2 &lt;= reg2 - 1'b1; if(reg2 == 4'd0) begin reg2 &lt;= 4'd3; reg1 &lt;= 2'd2; flag &lt;= 2'd2; end end else begin reg2 &lt;= reg2 - 1'b1; if(reg2 == 4'd0) begin flag &lt;= flag - 1'b1; reg1 &lt;= reg1 - 1'b1; reg2 &lt;= 4'd9; end end end end endcase end /************************************************/ assign hour_h = reg1; assign hour_l = reg2; assign minute_h = reg3; assign minute_l = reg4; /************************************************/endmodule 闹钟模块（alarm） 输入 功能说明 输出 功能说明 a_hour 闹钟小时控制 a_hour_h 闹钟小时高位 a_minute 闹钟分钟控制 a_hour_l 闹钟小时低位 clk 时钟 a_minute_h 闹钟分钟高位 rst_n 复位 a_minute_l 闹钟分钟低位 细节讲解闹钟模块与时钟模块的其实没什么区别，就是在调闹钟时，时钟正常运行，时钟调分，调时都会停止运行，也就是计数器不计数，其他的区别不大。 代码展示点击显\\隐代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123module alarm( input clk, input rst_n, input c_add, //控制 加 input c_sub, //控制 减 input [2:0]Time_model, output [1:0]a_hour_h, //闹钟小时 十位 output [3:0]a_hour_l, //闹钟小时 个位 output [2:0]a_minute_h, //闹钟分钟 十位 output [3:0]a_minute_l //闹钟分钟 个位 ); ////////////////////////////////////////////////////////// // 功能控制 // //////////////////////////////////////////////////////// reg [1:0]flag;//用来标志reg1是否到了2，到了2,reg2只能加到4 reg [1:0] reg1;//时的第一位：0~2 reg [3:0] reg2; //时的第二位：当第一位为0和1时，可以是0~9,当第一位为2时，只能是0~9, reg [2:0] reg3;//分的第一位：只能是0~5 reg [3:0] reg4;//分的第二位：是0~9 always @(posedge clk or negedge rst_n) begin if(!rst_n) begin reg1 &lt;= 2'd0; //闹钟小时 高位 reg2 &lt;= 4'd0; //闹钟小时 低位 reg3 &lt;= 3'd0; //闹钟分钟 高位 reg4 &lt;= 4'd0; //闹钟分钟 低位 flag &lt;= 2'd0; end else case(Time_model) //闹钟调分模式 3'b011: begin if(c_add)//加 begin reg4 &lt;= reg4 + 1'b1; if(reg4 == 4'd9) begin reg4 &lt;= 4'd0; reg3 &lt;= reg3 + 1'b1; if(reg3 &gt; 3'd4) reg3 &lt;= 3'd0; end end else if(c_sub)//减 begin reg4 &lt;= reg4 - 1'b1; if(reg4 == 4'd0) begin reg4 &lt;= 4'd9; reg3 &lt;= reg3 - 3'd1; if(reg3 == 3'd0) reg3 &lt;= 3'd5; end end end //闹钟调时模式 3'b100: begin if(c_add)//加 begin if(flag == 2'd2) begin reg2 &lt;= reg2 + 1'b1; if(reg2 &gt;= 4'd3) begin reg2 &lt;= 4'd0; reg1 &lt;= 2'd0; flag &lt;= 2'd0; end end else begin reg2 &lt;= reg2 + 1'b1; if(reg2 == 4'd9) begin flag &lt;= flag + 1'b1; reg2 &lt;= 4'd0; reg1 &lt;= reg1 + 1'b1; end end end else if(c_sub)//减 begin if(flag == 2'd0) begin reg2 &lt;= reg2 - 1'b1; if(reg2 == 4'd0) begin reg2 &lt;= 4'd3; reg1 &lt;= 2'd2; flag &lt;= 2'd2; end end else begin reg2 &lt;= reg2 - 1'b1; if(reg2 == 4'd0) begin flag &lt;= flag - 1'b1; reg1 &lt;= reg1 - 1'b1; reg2 &lt;= 4'd9; end end end end endcase end /************************************************/ assign a_hour_h = reg1; assign a_hour_l = reg2; assign a_minute_h = reg3; assign a_minute_l = reg4; /************************************************/endmodule 显示模块（display） 输入 功能说明 输出 功能说明 a_hour_h 闹钟小时高位 data 段选信号 a_hour_l 闹钟小时低位 select_wei 位选信号 a_minute_h 闹钟分钟高位 beep 蜂鸣器 a_minute_l 闹钟分钟低位 hour_h 时钟小时高位 hour_l 时钟小时低位 minute_h 时钟分钟高位 minute_l 时钟分钟低位 Display_Model 显示模式控制 clk 时钟 rst_n 复位 显示模块的输入有三种类型： 闹钟的数据 时钟的数据 显示模式控制信号 输出也只有三个 data是八段数码管的段选信号，由于我没用小数点，所以七根线 select_wei数码管位选，四个数码管，四根线 beep链接蜂鸣器的，一根线。 细节讲解显示模块里用到的主要是数码管动态扫描的知识，扫描频率如何设置，这些问题，查一下数码管的是如何显示就知道了，抓住段选和位选，还有动态扫描的原理，然后分清楚你使用的数码管是共阴还是共阳，这个显示模块就很好理解了。 代码展示点击显\\隐代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260module display( input clk, input rst_n, //时钟模式 双段选数据 input [1:0] hour_h, input [3:0] hour_l, input [2:0] minute_h, input [3:0] minute_l, //闹钟模式 段选数据 input [1:0] a_hour_h, input [3:0] a_hour_l, input [2:0] a_minute_h, input [3:0] a_minute_l, input Display_Model,//0:时钟模式，1：秒表模式 output [6:0] data,//数码管段选 output reg[3:0] select_wei, //数码管位选 output reg alarm_out );/***********************************/parameter SEG_0 = 7'h7e,//c0, SEG_1 = 7'h30,//f9, SEG_2 = 7'h6d,//a4, SEG_3 = 7'h79,//b0, SEG_4 = 7'h33,//99, SEG_5 = 7'h5b,//92, SEG_6 = 7'h5f,//82, SEG_7 = 7'h70,//F8, SEG_8 = 7'h7f,//80, SEG_9 = 7'h7b;//90, /***********************************/ //时钟数据编码 /***********************************/wire [6:0]c_data1;wire [6:0]c_data2;wire [6:0]c_data3;wire [6:0]c_data4;//数码管一要显示的列表数据（0~2）reg [6:0] data1_temp;always @(posedge clk or negedge rst_n) if(!rst_n) data1_temp &lt;= SEG_0; else case(hour_h) 2'd0: data1_temp &lt;= SEG_0; 2'd1: data1_temp &lt;= SEG_1; 2'd2: data1_temp &lt;= SEG_2; default: data1_temp &lt;= SEG_0; endcase/***********************************///数码管二要显示的列表数据（0~9）reg [6:0] data2_temp;always @(posedge clk or negedge rst_n) if(!rst_n) data2_temp &lt;= SEG_0; else case(hour_l) 4'd0: data2_temp &lt;= SEG_0; 4'd1: data2_temp &lt;= SEG_1; 4'd2: data2_temp &lt;= SEG_2; 4'd3: data2_temp &lt;= SEG_3; 4'd4: data2_temp &lt;= SEG_4; 4'd5: data2_temp &lt;= SEG_5; 4'd6: data2_temp &lt;= SEG_6; 4'd7: data2_temp &lt;= SEG_7; 4'd8: data2_temp &lt;= SEG_8; 4'd9: data2_temp &lt;= SEG_9; default: data2_temp &lt;= SEG_0; endcase/***********************************///数码管三要显示的列表数据 (0~5)reg [6:0] data3_temp;always @(posedge clk or negedge rst_n) if(!rst_n) data3_temp &lt;= SEG_0; else case(minute_h) 3'd0: data3_temp &lt;= SEG_0; 3'd1: data3_temp &lt;= SEG_1; 3'd2: data3_temp &lt;= SEG_2; 3'd3: data3_temp &lt;= SEG_3; 3'd4: data3_temp &lt;= SEG_4; 3'd5: data3_temp &lt;= SEG_5; default: data3_temp &lt;= SEG_0; endcase/***********************************///数码管四要显示的列表数据（1~9）reg [6:0] data4_temp;always @(posedge clk or negedge rst_n) if(!rst_n) data4_temp &lt;= SEG_0; else case(minute_l) 4'd0: data4_temp &lt;= SEG_0; 4'd1: data4_temp &lt;= SEG_1; 4'd2: data4_temp &lt;= SEG_2; 4'd3: data4_temp &lt;= SEG_3; 4'd4: data4_temp &lt;= SEG_4; 4'd5: data4_temp &lt;= SEG_5; 4'd6: data4_temp &lt;= SEG_6; 4'd7: data4_temp &lt;= SEG_7; 4'd8: data4_temp &lt;= SEG_8; 4'd9: data4_temp &lt;= SEG_9; default: data4_temp &lt;= SEG_0; endcase/*****************************************/assign c_data1 = data1_temp;assign c_data2 = data2_temp;assign c_data3 = data3_temp;assign c_data4 = data4_temp;/*****************************************/ /***********************************/ //闹钟数据编码 /***********************************/wire [6:0]a_data1;wire [6:0]a_data2;wire [6:0]a_data3;wire [6:0]a_data4;//数码管一要显示的列表数据（0~5）reg [6:0] a_data1_temp;always @(posedge clk or negedge rst_n) if(!rst_n) a_data1_temp &lt;= SEG_0; else case(a_hour_h) 3'd0: a_data1_temp &lt;= SEG_0; 3'd1: a_data1_temp &lt;= SEG_1; 3'd2: a_data1_temp &lt;= SEG_2; 3'd3: a_data1_temp &lt;= SEG_3; 3'd4: a_data1_temp &lt;= SEG_4; 3'd5: a_data1_temp &lt;= SEG_5; default: a_data1_temp &lt;= SEG_0; endcase/***********************************///数码管二要显示的列表数据（0~9）reg [6:0] a_data2_temp;always @(posedge clk or negedge rst_n) if(!rst_n) a_data2_temp &lt;= SEG_0; else case(a_hour_l) 4'd0: a_data2_temp &lt;= SEG_0; 4'd1: a_data2_temp &lt;= SEG_1; 4'd2: a_data2_temp &lt;= SEG_2; 4'd3: a_data2_temp &lt;= SEG_3; 4'd4: a_data2_temp &lt;= SEG_4; 4'd5: a_data2_temp &lt;= SEG_5; 4'd6: a_data2_temp &lt;= SEG_6; 4'd7: a_data2_temp &lt;= SEG_7; 4'd8: a_data2_temp &lt;= SEG_8; 4'd9: a_data2_temp &lt;= SEG_9; default: a_data2_temp &lt;= SEG_0; endcase/*****************************************///数码管三要显示的列表数据（0~9）reg [6:0] a_data3_temp; always @(posedge clk or negedge rst_n) if(!rst_n) a_data3_temp &lt;= SEG_0; else case(a_minute_h) 4'd0: a_data3_temp &lt;= SEG_0; 4'd1: a_data3_temp &lt;= SEG_1; 4'd2: a_data3_temp &lt;= SEG_2; 4'd3: a_data3_temp &lt;= SEG_3; 4'd4: a_data3_temp &lt;= SEG_4; 4'd5: a_data3_temp &lt;= SEG_5; 4'd6: a_data3_temp &lt;= SEG_6; 4'd7: a_data3_temp &lt;= SEG_7; 4'd8: a_data3_temp &lt;= SEG_8; 4'd9: a_data3_temp &lt;= SEG_9; default: a_data3_temp &lt;= SEG_0; endcase/***********************************///数码管四要显示的列表数据（0~9）reg [6:0] a_data4_temp;always @(posedge clk or negedge rst_n) if(!rst_n) a_data4_temp &lt;= SEG_0; else case(a_minute_l) 4'd0: a_data4_temp &lt;= SEG_0; 4'd1: a_data4_temp &lt;= SEG_1; 4'd2: a_data4_temp &lt;= SEG_2; 4'd3: a_data4_temp &lt;= SEG_3; 4'd4: a_data4_temp &lt;= SEG_4; 4'd5: a_data4_temp &lt;= SEG_5; 4'd6: a_data4_temp &lt;= SEG_6; 4'd7: a_data4_temp &lt;= SEG_7; 4'd8: a_data4_temp &lt;= SEG_8; 4'd9: a_data4_temp &lt;= SEG_9; default: a_data4_temp &lt;= SEG_0; endcase/*******************************************************/ assign a_data1 = a_data1_temp;assign a_data2 = a_data2_temp;assign a_data3 = a_data3_temp;assign a_data4 = a_data4_temp;/***************************************************//******************************************/parameter shuaxin = 17'h1ffff;// 数码管扫描频率reg [19:0] cnt; reg [1:0] num;//每隔5MS，num加1always @(posedge clk or negedge rst_n) if(!rst_n) begin select_wei &lt;= 4'd8; // 1000 cnt &lt;= 18'd0; num &lt;= 2'd0; end else if(cnt == shuaxin) begin num &lt;= num + 1'b1; cnt &lt;= 18'd0; if(select_wei == 4'd1) //0001 select_wei &lt;= 4'd8; else select_wei &lt;= &#123;1'b0,select_wei[3:1]&#125;; //右移 end else cnt &lt;= cnt + 1'b1;/******************************************///通过Display_Model来确定是要送秒表数据还是闹钟的数据reg [7:0] data_temp;always @(posedge clk or negedge rst_n)begin if(!rst_n) data_temp &lt;= 7'h7e; else if(cnt == shuaxin) case(num) 2'd0: data_temp &lt;= Display_Model ? a_data1:c_data1;//给第一个数码管送数据 2'd1: data_temp &lt;= Display_Model ? a_data2:c_data2;//给第二个数码管送数据 2'd2: data_temp &lt;= Display_Model ? a_data3:c_data3;//给第二个数码管送数据 2'd3: data_temp &lt;= Display_Model ? a_data4:c_data4;//给第二个数码管送数据 endcaseendassign data = data_temp;/******************************************/ ////// 比较器模块 //////always @(posedge clk or negedge rst_n)begin if(!rst_n) alarm_out &lt;= 0 ; else if(a_data1 == c_data1 &amp;&amp; a_data2 == c_data2 &amp;&amp; a_data3 == c_data3 &amp;&amp; a_data4 == c_data4) alarm_out &lt;=1; else alarm_out&lt;=0;endendmodule top层主要是链接，直接上代码吧。 代码展示点击显\\隐代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130module top( input clk, input rst_n, input add_in, input sub_in, input model_in, output [6:0] data,//数码管段选数据 output [3:0] select_wei, //数码管位选 output alarm_out );wire [1:0] hour_h;wire [3:0] hour_l;wire [2:0] minute_h;wire [3:0] minute_l;wire [1:0] a_hour_h;wire [3:0] a_hour_l;wire [2:0] a_minute_h;wire [3:0] a_minute_l;wire Display_Model;wire [2:0]Time_model;wire c_add;wire c_sub;wire a_add; wire a_sub;wire cnt_control; //控制定时器//key U1( //top的input .clk(clk), .rst_n(rst_n), .add_in(add_in), .sub_in(sub_in), .model_in(model_in), //连clock的线 .cnt_control(cnt_control), .c_add(c_add), .c_sub(c_sub), .Time_model(Time_model), //连alarm的线 .a_add(a_add), .a_sub(a_sub), //连display的线 .Display_Model(Display_Model) ); clock U2( //input .clk(clk), .rst_n(rst_n), //从key来的线 .c_add(c_add), .c_sub(c_sub), .cnt_control(cnt_control), .Time_model(Time_model), //output //连display的线 .hour_h(hour_h), .hour_l(hour_l), .minute_h(minute_h), .minute_l(minute_l) );alarm U3( //input .clk(clk), .rst_n(rst_n), //从key来的线 .c_add(a_add), .c_sub(a_sub), .Time_model(Time_model), //output //连display的线 .a_hour_h(a_hour_h), .a_hour_l(a_hour_l), .a_minute_h(a_minute_h), .a_minute_l(a_minute_l) ); display U4( //input .clk(clk), .rst_n(rst_n), //从clock 来的线 .hour_h(hour_h), .hour_l(hour_l), .minute_h(minute_h), .minute_l(minute_l), //从alarm 来的线 .a_hour_h(a_hour_h), .a_hour_l(a_hour_l), .a_minute_h(a_minute_h), .a_minute_l(a_minute_l), //从key 来的线 .Display_Model(Display_Model), //output .data(data), .select_wei(select_wei), .alarm_out(alarm_out) ); endmodule 细节讲解top层的作用是连接各个模块，列出系统的输入输出，然后分清楚中间节点，如果之前没有写过top层，可以先从试着写个小系统，比如：全加器（调用半加器实现），如果你已经是老司机，相信已经驾轻就熟了，不多说了。其实，我这个例化写得有点烦了，例化如果非要分写法可以分为两种，我这是比较烦的，不过我也不改了，╭(╯^╰)╮ 写在后面的话数字钟就讲诉到这里，整个系统不难理解，只是模块之间的联系必须弄清楚，我的观点是：把需要的模块列出来，分析模块之间的联系，再具体看各个模块的内容，单个验证，自顶向下设计，主要还是多琢磨吧，有耐心就好。 关于文章，如果有任何问题都可以在评论区和我交流，如果有错误，欢迎斧正，谢谢了~~","categories":[{"name":"搞硬件","slug":"搞硬件","permalink":"http://www.luheng.online/categories/搞硬件/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://www.luheng.online/tags/FPGA/"}]},{"title":"matlab实现快速傅里叶变换","slug":"matlab实现快速傅里叶变换","date":"2017-11-09T08:05:45.000Z","updated":"2017-12-30T12:17:22.749Z","comments":true,"path":"2017/11/09/matlab实现快速傅里叶变换/","link":"","permalink":"http://www.luheng.online/2017/11/09/matlab实现快速傅里叶变换/","excerpt":"傅里叶变换是能将信号从时域转到频域的一种变换形式，是我们分析信号的常用方法，毕竟相比于时域的纷乱复杂，频域显得清爽很多。有关傅里叶变换的理解，可以看我之前转载的一篇文章：【转载】傅里叶分析之掐死教程（完整版） 。本篇文章主要介绍快速傅里叶变换（FFT）的一种，基2FFT，讲诉计算原理和提供相应的matlab代码。","text":"傅里叶变换是能将信号从时域转到频域的一种变换形式，是我们分析信号的常用方法，毕竟相比于时域的纷乱复杂，频域显得清爽很多。有关傅里叶变换的理解，可以看我之前转载的一篇文章：【转载】傅里叶分析之掐死教程（完整版） 。本篇文章主要介绍快速傅里叶变换（FFT）的一种，基2FFT，讲诉计算原理和提供相应的matlab代码。 DFT和FFTDFT是离散傅里叶变换，是傅里叶变换在离散系统的表现形式。离散信号x(n)的傅里叶变换可以表示为：其中k=0,1,2…N-1,所以DFT的运算量为N的平方，当N取值很大时，计算量就会十分巨大。所以需要找一些算法去优化它的计算，减少计算量，这便是FFT，快速傅里叶变换。 一般来说，FFT算法主要分为两种类型，时域抽取和频域抽取。两者的区别主要是提取数列的方法不一致，在计算上表现为蝶形因子的位置不同，前者蝶形因子出现在输入端，后者出现在输出端。 以N=8为例，时域抽取：频域抽取 基2FFT计算原理本文所写的FFT以时域抽取为例，频域抽取不作讲解，下面是计算过程。 时间抽取FFT是将N点输入序列x(n)，按照奇偶分为奇数列和偶数列。奇数列：x(1),x(3),x(5)….x(N-1)偶数列：x(0),x(2),x(4)….x(N-2) 由于旋转因子具备对称性和周期性（周期为N/2），所以可以得到： 如果对X1(k)和X2(K)继续用这样的办法分解下去，最终一个N点的DFT可以用一组2点的DFT去计算。所以在基2的FFT中，总共有log2(N)级运算，每级有N/2个2点FFT的蝶形运算。 这里我想说得再清晰一些，可是感觉自己表诉得不够准确，害怕误导大家，所以计算过程希望读者还是自己算一遍下来，去感受一下,相信你们会有感悟，如有问题，欢迎大家和在评论区交流。 单个蝶形运算图示 N=8时，时间抽取FFT的运算流图如下： 直接计算DFT和基2FFT算法运算量比较直接计算DFT由公式：它的运算量为N^2。 根据FFT的运算规则可见，当N=2^M时，从运算流图可以看出，应该会用M级蝶形，每一级都有N/2个蝶形运算构成。因此，每一级都需要N/2复数乘和N次复数加（每个蝶形需要两次复数加法），所以： M级运算总的复数乘次数为: MN/2 = log2（N）（N/2）复数的加次数为： MN = Nlog2(N) 当 N&gt;&gt;1 时，N^2&gt;&gt;og2（N）*（N/2），所以基2FFT算法比直接计算DFT得到运算量大大减少。 matlab程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677A=input(&apos;请输入序列A：&apos;);N=input(&apos;请输入N：&apos;);L=length(A(:)); %输入序列长度b=0;if(N&lt;L) P=input(&apos;由于N小于序列长度，采样信号不完整，计算无意义，建议重新输入N\\n 1:重新输入N\\n 0：坚持计算\\n&apos;); if(P==1) N=input(&apos;请输入N：&apos;); while(N&lt;L) N=input(&apos;N仍小于序列长度，请重新输入：\\n&apos;); end endendwhile 1 M=log2(N); %M是层数 if(M==fix(M)) % 判断是否适合做快速傅里叶变换 if( log2(L) &lt; M) while(log2(L+b)~=M) b=b+1; end for n=L+1:1:L+b A(n)=0; end L=length(A); end X0=myfft(A,M); X1=fft(A,N); X2=myfft(A,M)-fft(A,N); %%%% 画图 subplot(4,1,1); stem(A); title(&apos;A序列&apos;); subplot(4,1,2); stem(X0); title(&apos;A序列的myfft&apos;); subplot(4,1,3); stem(X1); title(&apos;A序列的fft&apos;); subplot(4,1,4); stem(X2); title(&apos;myfft-fft&apos;); %%%%% flag=1; break; else y=input(&apos;N点不适合做快速傅里叶变换，现在您有两个选择\\n 0：重新输入N\\n 1：使用直接傅里叶变换\\n&apos;); if(y==0) N=input(&apos;请重新输入N\\n&apos;); if(N&lt;L) P=input(&apos;由于N小于序列长度，采样信号不完整，计算无意义，建议重新输入N\\n 1:重新输入N\\n 0：坚持计算\\n&apos;); if(P==1) N=input(&apos;请输入N：&apos;); while(N&lt;L) N=input(&apos;N仍小于序列长度，请重新输入：\\n&apos;); end end end else if(y==1) X1=fft(A,N); subplot(2,1,1); stem(A); title(&apos;A序列&apos;); subplot(2,1,2); stem(X1); title(&apos;A序列的DFT&apos;); break; else fprintf(&apos;拜托！只有0和1两个选择，— —#\\n&apos;); end end endend FFT函数文件：123456789101112131415161718192021222324252627282930313233343536373839%% myfft函数，此程序是用来调用的function [A] = myfft(A,M) N=2^M; % M 表示层数LH=N/2; J=LH; N1=N-2; %倒序程序for I=1:1:N1 if I&lt;J T=A(I+1); A(I+1)=A(J+1); A(J+1)=T; end K=LH; if J&gt;=K J=J-K; K=K/2; end J=J+K;endfor L=1:1:M B=2^(L-1); for J=0:B-1 p=J*2^(M-L); for k=J:2^L:N-1 T=A(k+1)+A(k+B+1)*exp(-1i*2*pi*p/N); A(k+B+1)=A(k+1)-A(k+B+1)*exp(-1i*2*pi*p/N); A(k+1)=T; end endendB=(0);for i=1:2^M B(i)=A(i);endA=B; 这里说下程序的特点，由于快速傅里叶变换本身因为计算的原因，要求输入的N应该为2^M（M是级数）即类似2，4，8，16…这些数字，所以当输入N=3，6，12时，我们并不能进行快速傅里叶变换，不过在程序中我加入了修改提示，还顺便卖萌装年轻，算是比较人性化的一部分。 此外，还有输入序列x(n)的长度和N之间的关系处理：当N &gt; 数列长度时，说明采样点过多，需要我们为序列后面补零，这点在程序中我也添加了。当N &lt; 数列长度，说明采样不足，实际上这样的采样对输入的信号绝对是会有损耗的，即便计算出来也没有太大的意义，除非有专门的算法做处理，类似一些压缩技术，不然计算的结果只是数学上的数字，对实际并没有多大的用途。 当输入一个周期的正弦序列A，信号长度为32,N=32时，效果如下图。 关于程序或者文章的问题，欢迎和我在评论区和我讨论，有打赏就更好了。如文章有错误，请斧正。 参考文献数字信号处理（高西全，丁美玉）.西安电子科技大学出版社手把手教你理解(FFT).百度文库还有好几篇不记得了在哪找的PPT（—— ——#） 本文完。","categories":[{"name":"搞软件","slug":"搞软件","permalink":"http://www.luheng.online/categories/搞软件/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://www.luheng.online/tags/matlab/"}]},{"title":"FPGA.矩阵键盘","slug":"FPGA.矩阵键盘","date":"2017-11-03T03:50:27.000Z","updated":"2018-01-08T02:37:53.527Z","comments":true,"path":"2017/11/03/FPGA.矩阵键盘/","link":"","permalink":"http://www.luheng.online/2017/11/03/FPGA.矩阵键盘/","excerpt":"矩阵键盘是外部设备中所使用的排布类似于矩阵的键盘组。矩阵式结构的键盘显然比直接法要复杂一些，识别也要复杂一些，列线通过电阻接正电源，并将行线所接的芯片的I/O口作为输出端，而列线所接的I/O口则作为输入。 本文简单的讲诉下矩阵键盘的扫描原理，给出相应的代码和测试文件。","text":"矩阵键盘是外部设备中所使用的排布类似于矩阵的键盘组。矩阵式结构的键盘显然比直接法要复杂一些，识别也要复杂一些，列线通过电阻接正电源，并将行线所接的芯片的I/O口作为输出端，而列线所接的I/O口则作为输入。 本文简单的讲诉下矩阵键盘的扫描原理，给出相应的代码和测试文件。矩阵键盘是常用的输入设备，由于相较于传统的单个按键，它能很好的节省宝贵的I/O接口。怎么节省的呢？下面以4x4矩阵键盘举例说明原因。 原理解释首先说明，FPGA中我们常说的写矩阵键盘，其实是在书写判断键盘输入是哪一个按键的，并译码输出相应数据的芯片，是一个芯片。键盘就是键盘，我们不可能把它“写”出来。 我们写的就是左边的芯片，那该怎么书写？我们需要先弄清楚矩阵键盘的工作原理，看下图，通过图片理解比较直观点。 从上图我们可以看出，对于4x4矩阵键盘来说，它是四输出，四输入。 而且键盘的输出即芯片的输入，键盘的输入即芯片的输出，有点拗口，不过看图还是不难理解的。 为了方便讲解，我先设定一些值，说明原理时比较好说明。设输入的四根线，也就是行，设为[3:0]col；输出的四根线，也就是列，设为[3:0]row；将它们组合一下，行列就能决定一个点 设键值 row_col = {row,col}。 我们设定一个初始状态，对于芯片来说，输出[3:0]col是能控制的，那没有按键按下时，我让它都是 0 就好了，为什么不是 1，因为键盘的另一端，是高电平，不能和它一样啊，不然键盘按下的时候，反馈给芯片的输入就没有变化了。当你读到这或许还不能理解这一点，不过没关系，我尽力去解释清楚。 看键盘的四输入[3:0]col ， 四输出[3:0]row。假如没有按键按下时，芯片给的四个输出都是0，输入的按键由于外部连的高电平的作用，给芯片的输入都是1，本来呢，要是你有按键按下，就能把0接到输入，输入也就不用全是1了，但是你没有， 所以在没有按键按下时，芯片中的数据 row_col = 1111_0000。 要是现在想按了，而且还按了，就是下面这个键。会发生什么呢？ 由于按下了，也就是接通了按键左边的0 ，那么反馈回去的数据就变成了 row_col=1101_0000,令前面的1111 ，变成了1101的“凶手”，肯定是你后面四个0的某一个造成的。但对于芯片来说我是不知道你是哪个 0 造成的，也就是说目前芯片知道了是哪一列，但哪一行不知道。为了找出是那一个0，我让芯片的四个输出，也就是四行，只有一个是0，一个个排查，也就是键盘行扫描。 先从1110开始，1111不变成1101，那就换一行变成1101试试，不行再变，变成1011，直到找到使芯片输入变成了1011的那一行，这样行，列都知道了就能确定一个点。显然，我按下的那个键 row_col = 1101_1101。 按键消抖这部分，在这里不属于重点，不多解释了，主要就是个延时，在程序中也不难看懂。 具体的操作看代码吧。 源程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187`timescale 1ns / 1psmodule key_scan( input clk, input rst_n, //系统复位 input [3:0]row, //FPGA输入，行 output reg flag, //输出值有效标志位 output reg [3:0] data , //按键值 output reg [3:0] y,//根据按键功能给出相应功能 output reg [3:0]col //FPGA 输出 ，列 ); /////////////////////////////////// // 分频电路 // ///////////////////////////////// //当然需不需要分频，看你具体需求了，但这里给出代码 reg clk_1k;//1k Hz的时钟 reg [20:0] count; //计数器 parameter T1k = 10;//这个分频为了方便仿真，随意定了个较小的值，10分分频 always @(posedge clk or negedge rst_n) begin if(!rst_n) begin clk_1k &lt;= 1; count &lt;= 0; end else if(count &lt; T1k/2) count &lt;= count + 1; else begin count &lt;= 0 ; clk_1k &lt;= ~clk_1k; end end //////////////////////////////////// // 键盘扫描电路 // /////////////////////////////////// reg [4:0]cnt_time;//按键按下的时间 reg [1:0]state; //状态寄存器 reg [7:0]row_col; //按键对应的行列值 always @(posedge clk_1k or negedge rst_n) begin if(!rst_n) begin flag &lt;= 0; state &lt;= 0; cnt_time &lt;= 0; row_col &lt;= 0; col &lt;= 4&apos;b0_000; end else begin case(state) // 状态 0 是判断是否有按键按下，如果有，开始列扫描 0 : begin if(row != 4&apos;b1111) //检测是否有按键按下，row是输入的。 begin if(cnt_time &lt; 5) //按键时间大于一定的值，认为确实是按下了 cnt_time &lt;= cnt_time + 1; else begin cnt_time &lt;= 0; state &lt;=1; col &lt;= 4&apos;b1110; //行扫描的初始值 end end else cnt_time = 0; end //状态 0 是对列进行逐列扫描 1:begin if(row != 4&apos;b1111) begin row_col &lt;= &#123;row,col&#125;;//键值的行列记录下来 flag &lt;= 1 ; //拉高有效标志位，确定扫描点 state &lt;= 2; col &lt;= 4&apos;b0_000;//回到没有按下的状态 end else begin col &lt;= &#123;col[2:0],col[3]&#125;; end //不是初始按键的列 1110，换一列，变为1101,相当于一个循环移位 end //状态 2 检测按键是否被释放，如果被释放，回到初始状态 2:begin if(row == 4&apos;b1111) begin if(cnt_time &lt; 5) begin cnt_time &lt;= cnt_time + 1; end else begin cnt_time &lt;= 0; state &lt;= 0; col &lt;= 4&apos;b000; end end else begin cnt_time &lt;=0; flag &lt;= 0; end end default : state &lt;= 0; endcase end end ////////////////////////////////// // 编码 // ///////////////////////////////// always @(*) begin if(!rst_n) begin data = 0; end else begin case(row_col) 8&apos;b1110_1110: data = 0; 8&apos;b1110_1101: data = 1; 8&apos;b1110_1011: data = 2; 8&apos;b1110_0111: data = 3; 8&apos;b1101_1110: data = 4; 8&apos;b1101_1101: data = 5; 8&apos;b1101_1011: data = 6; 8&apos;b1101_0111: data = 7; 8&apos;b1011_1110: data = 8; 8&apos;b1011_1101: data = 9; 8&apos;b1011_1011: data = 10; 8&apos;b1011_0111: data = 11; 8&apos;b0111_1110: data = 12; 8&apos;b0111_1101: data = 13; 8&apos;b0111_1011: data = 14; 8&apos;b0111_0111: data = 15; default: data = 16; endcase end end ////////////////////////////////// // 译码 // ///////////////////////////////// //对按键译码就是把按键的功能安排好，我随便把它变为数字的16进制了 always @(*) begin if(!rst_n) begin data = 0; end else begin case(data) 0: y=4&apos;b0_000; 1: y=4&apos;b0_001; 2: y=4&apos;b0_010; 3: y=4&apos;b0_011; 4: y=4&apos;b0_101; 5: y=4&apos;b0_101; 6: y=4&apos;b0_110; 7: y=4&apos;b0_111; 8: y=4&apos;b1_000; 9: y=4&apos;b1_001; 10: y=4&apos;b1_010; 11: y=4&apos;b1_011; 12: y=4&apos;b1_100; 13: y=4&apos;b1_101; 14: y=4&apos;b1_110; 15: y=4&apos;b1_111; default: y=4&apos;b0_000; endcase end end //译码电路，当个例子，实际情况请根据自身需要修改。endmodule tb测试文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101module tb_keyscan; reg clk; reg rst_n; reg [3:0]row; wire flag; wire [3:0]data; wire [3:0]y; wire [3:0]col; //例化 key_scan uut( .clk(clk),.rst_n(rst_n),.row(row), .flag(flag),.data(data),.y(y),.col(col) ); initial begin clk = 0; rst_n = 0; #10; rst_n = 1; //先复位一段时间再启动 end always #10 clk=~clk; //50M时钟信息 reg [4:0]pnumber; //按键值 initial begin pnumber = 16;//无按键按下 #10 pnumber = 1; #10 pnumber = 16; //模拟抖动 #10 pnumber = 1; #10 pnumber = 16; #10 pnumber = 1; #10 pnumber = 16; #10 pnumber = 1; #10 pnumber = 16; #10 pnumber = 1; #10; pnumber = 1;//按键 1 按下 #2500 pnumber = 16; //模拟释放时的抖动 #10 pnumber = 1; #10 pnumber = 16; #10 pnumber = 1; #10 pnumber = 16; #10 pnumber = 1; #10 pnumber = 16; #2000; //松开 pnumber = 2;//按键 2 按下 #2500 pnumber = 16; //模拟释放时的抖动 #10 pnumber = 1; #10 pnumber = 16; #10 pnumber = 1; #10 pnumber = 16; #10 pnumber = 1; #10 pnumber = 16; #2000; //松开 pnumber = 3;//按键 3 按下 #2500 pnumber = 16; //模拟释放时的抖动 #10 pnumber = 1; #10 pnumber = 16; #10 pnumber = 1; #10 pnumber = 16; #10 pnumber = 1; #10 pnumber = 16; #2000; //松开 end always @(*) begin case(pnumber) 0: row = &#123;1&apos;b1,1&apos;b1,1&apos;b1,col[0]&#125;; 1: row = &#123;1&apos;b1,1&apos;b1,1&apos;b1,col[1]&#125;; 2: row = &#123;1&apos;b1,1&apos;b1,1&apos;b1,col[2]&#125;; 3: row = &#123;1&apos;b1,1&apos;b1,1&apos;b1,col[3]&#125;; 4: row = &#123;1&apos;b1,1&apos;b1,col[0],1&apos;b1&#125;; 5: row = &#123;1&apos;b1,1&apos;b1,col[1],1&apos;b1&#125;; 6: row = &#123;1&apos;b1,1&apos;b1,col[2],1&apos;b1&#125;; 7: row = &#123;1&apos;b1,1&apos;b1,col[3],1&apos;b1&#125;; 8: row = &#123;1&apos;b1,col[0],1&apos;b1,1&apos;b1&#125;; 9: row = &#123;1&apos;b1,col[1],1&apos;b1,1&apos;b1&#125;; 10: row = &#123;1&apos;b1,col[2],1&apos;b1,1&apos;b1&#125;; 11: row = &#123;1&apos;b1,col[3],1&apos;b1,1&apos;b1&#125;; 12: row = &#123;col[0],1&apos;b1,1&apos;b1,1&apos;b1&#125;; 13: row = &#123;col[1],1&apos;b1,1&apos;b1,1&apos;b1&#125;; 14: row = &#123;col[2],1&apos;b1,1&apos;b1,1&apos;b1&#125;; 15: row = &#123;col[3],1&apos;b1,1&apos;b1,1&apos;b1&#125;; 16: row = 4&apos;b1111; default : row = 4&apos;b1111; endcase end endmodule 代码的写法有很多，各有优劣，我这也只是给出我的想法，有错误请斧正，欢迎大家在评论区与我交流，打赏就更好了。 本文完。","categories":[{"name":"搞硬件","slug":"搞硬件","permalink":"http://www.luheng.online/categories/搞硬件/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://www.luheng.online/tags/FPGA/"}]},{"title":"FPGA.赋值语句","slug":"FPGA.赋值语句","date":"2017-10-27T01:37:17.000Z","updated":"2018-01-08T02:38:00.659Z","comments":true,"path":"2017/10/27/FPGA.赋值语句/","link":"","permalink":"http://www.luheng.online/2017/10/27/FPGA.赋值语句/","excerpt":"赋值语句应该是开发过程中使用最多的语句，在FPGA中，赋值语句分为“非阻塞赋值”和“阻塞赋值”，什么是“非阻塞赋值”？ 什么是“阻塞赋值”？它们的区别在哪？下面用具体实例来说明。","text":"赋值语句应该是开发过程中使用最多的语句，在FPGA中，赋值语句分为“非阻塞赋值”和“阻塞赋值”，什么是“非阻塞赋值”？ 什么是“阻塞赋值”？它们的区别在哪？下面用具体实例来说明。 不论学习什么语句，都是先认识，了解一下它再去使用，所谓”知己知彼，方可百战不殆”。 非阻塞赋值赋值很好理解，重点在“非阻塞”，“阻塞” 就是 堵 ，“非”表 否定。非阻塞就是通畅嘛，那通畅怎么样的？ 先看下面这段代码12345initial begin A &lt;= B; // 语句1 B &lt;= A; // 语句2 end 其中操作符 “&lt;=” 就是非阻塞型幅值语句。我们看begin — end里的两个句子，到底哪个先执行呢？ 答案是同时执行，因为它是非阻塞幅值，一路通畅啊，谁也拦不了我，我走我的，你走你的，互不干扰，通畅就通畅在这里。 现在提个问题：若A=1,B=2,那么执行以上语句后，A和B会变成什么呢？ 想知道答案，我最好的办法就是编程，然后仿真看下结果。 源文件 1234567891011121314151617181920212223242526///////////////////////////// 文件名：非阻塞赋值语句 //// 修改时间：2017.10.27 /////////////////////////////`timescale 1ns / 1psmodule n_assignment( input wire clk, input wire rst, output reg [1:0]A,B ); always @(posedge clk,negedge rst) begin if(!rst) begin A &lt;= 1; B &lt;= 2; end else begin A &lt;= B; B &lt;= A; end endendmodule 写tb文件看下效果12345678910111213141516171819202122`timescale 1ns / 1psmodule tb_n_assignment; reg clk; reg rst; wire [1:0]A; wire [1:0]B; //例化 n_assignment uuit(.clk(clk),.rst(rst),.A(A),.B(B)); initial begin rst = 0;#100; rst = 1; end always begin clk=1;#10; clk=0;#10; endendmodule 这样我们从仿真图可以看出，这段代码实现的功能是将A,B两者的数据转换，也就是说执行 begin A &lt;= B; // 语句1 B &lt;= A; // 语句2 end A,B同时给对方值，给的是自己的初值，当一赋值之后就变成了对方＜（＾－＾）＞，这就类似两名相向跑步的运动员，起点便是初值，我们同时出发，速度都一样，所以A到了B出点时，B也到了A的出发点，也就是 A&lt;=B,B&lt;=A，我变成了你，你变成了我。非阻塞赋值就是这样啦，下面看阻塞型赋值。 阻塞型赋值阻塞型赋值说明在赋值时堵住了，那这堵又是怎么回事呢？老办法，写代码做实验，仿真看结果。1234567891011121314151617181920212223242526///////////////////////////// 文件名：阻塞赋值语句 //// 修改时间：2017.10.27 /////////////////////////////`timescale 1ns / 1psmodule assignment( input wire clk, input wire rst, output reg [1:0]A,B ); always @(posedge clk,negedge rst) begin if(!rst) begin A = 1; B = 2; end else begin A = B; B = A; end endendmodule tb文件123456789101112131415161718192021module tb_assignment; reg clk; reg rst; wire [1:0]A; wire [1:0]B; //例化 assignment uuit(.clk(clk),.rst(rst),.A(A),.B(B)); initial begin rst = 0;#100; rst = 1; end always begin clk=1;#10; clk=0;#10; endendmodule 可以看出这段代码的功能不再是交换A,B两者的值了,毕竟代码改了，赋值变成阻塞的了，功能当然不一样，这好像是废话，(lll￢ω￢)我们再看看这段代码 begin A = B; B = A; //注意赋值是阻塞的 end 它是先执行A=B,B把自身的值给了A，然后再执行A=B。就像接力赛，前面的执行了后面才能执行，语句A拿着接力棒，跑完了自己的路程,即执行了自己的语句，把接力棒交给语句B，B才能往前走，去执行它的语句。 电路构成的差异比较好的，通过上面的两个例子，非阻塞型赋值和阻塞型的性质的都解释好了，下面再看下它们形成电路上的差异。我们看这段代码12345678910111213module and_block_assign( input wire a,b,c, output reg y)always @* begin y=a; y=y&amp;b; y=y&amp;c; endendmodule 以上代码描述的电路是这样的 但是阻塞赋值语句变成非阻塞赋值语句后，也就是下面这段代码12345678910111213module and_block_assign( input wire a,b,c, output reg y)always @* begin y&lt;=a; y&lt;=y&amp;b; y&lt;=y&amp;c; endendmodule 它描述的电路却是这样的 可以看出两者的差别是还是很大的，好了，关于赋值语句我就唠叨到这里，文章若有什么错误的地方希望读者指出，同时也欢迎大家和我在评论区交流，当然打赏那是最好不过的了。","categories":[{"name":"搞硬件","slug":"搞硬件","permalink":"http://www.luheng.online/categories/搞硬件/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://www.luheng.online/tags/FPGA/"}]},{"title":"FPGA.计数器书写——以60进制、24进制举例","slug":"FPGA.计数器书写——以60进制、24进制举例","date":"2017-10-20T13:58:42.000Z","updated":"2018-01-08T02:38:14.023Z","comments":true,"path":"2017/10/20/FPGA.计数器书写——以60进制、24进制举例/","link":"","permalink":"http://www.luheng.online/2017/10/20/FPGA.计数器书写——以60进制、24进制举例/","excerpt":"计数器在数字系统中主要是对脉冲的个数进行计数，以实现测量、计数和控制的功能，同时兼有分频功能。其实说白了，就是正常使用的情况下，你来个脉冲信号，我给你+1。当然实际情况下，为满足我的需要，我们会为计数器加上一“功能”，如：置数，复位。具体情况根据需要而定，但不管怎样，计数器都是较为简单的。","text":"计数器在数字系统中主要是对脉冲的个数进行计数，以实现测量、计数和控制的功能，同时兼有分频功能。其实说白了，就是正常使用的情况下，你来个脉冲信号，我给你+1。当然实际情况下，为满足我的需要，我们会为计数器加上一“功能”，如：置数，复位。具体情况根据需要而定，但不管怎样，计数器都是较为简单的。 60进制计数器60机制计数器，也就是从0数到59，然后清零，再来过。如此反复，每到60的时候输出一次脉冲信号。废话不多说,直接看代码。123456789101112131415161718192021222324252627282930313233343536-------------------------创建时间：2017.10.20 -创建人：Robin -文件名：counter60 -----------------------`timescale 1ns / 1psmodule counter60(input clk,clear,load,en, //时钟，清零，置数，使能input [3:0]dl,dh, //输入output reg [3:0] ql,qh, //输出output cout //进位 ); always @(posedge clk,negedge clear) if(!clear) //清零 begin ql&lt;=0;qh&lt;=0; end else if(load) begin ql&lt;=dl; //置数 qh&lt;=dh; end else if(en) if(ql==4&apos;h9) begin ql&lt;=0; if(qh==4&apos;h5) qh&lt;=0; else qh&lt;=qh+1; end else ql&lt;=ql+1; assign cout=(en==1&apos;b1 &amp;&amp; qh==4&apos;d5 &amp;&amp; ql==4&apos;d9)?1&apos;b1:1&apos;b0;endmodule 简单说下书写的思路，设计60进制的高低位为[3:0]ql，qh。用高、低两位数表示60因为我们人习惯使用十进制,但是计算机是用二进制的，所以ql，qh是[3:0]四位二进制。cout为计数器的输出。通常来说，低位一直+1,由0~9，当低位是9，如果高位没到5，那么下一个脉冲来的时候，低位清零，高位+1，就像29，变为30。若低位是9，而且高位是5，也就是数到59了，再来个脉冲，两者清零。至于清零，和使能，置数这些，看代码应该很容易理解的。 Tb文件以下的Tb测试文件，该部分请根据需要改变参数。123456789101112131415161718192021222324252627282930313233343536373839-------------------------创建时间：2017.10.20 -创建人：Robin -文件名：Tb_counter60 -----------------------`timescale 1ns / 1psmodule tb_counter; reg clk,clear,load,en; reg [3:0] dl,dh; wire [3:0] ql,qh; wire cout; //例化语句 counter60 uut(.clk(clk),.clear(clear),.load(load),.en(en),.dl(dl),.dh(dh),.ql(ql),.qh(qh),.cout(cout)); //时钟信号，周期是30ns always begin clk&lt;=1;#15; clk&lt;=0;#15; end //清零，先清零让ql，qh等于0，再启动 initial begin clear=0;#30; clear=1; end //置数 initial begin dl=1;dh=1; load=0;#800; load=1;#500; end //使能信号 initial begin en=0;#200; en=1; endendmodule 24进制计数器下面放上24进制的计数器源代码，代码不难理解，就不再过多解释了。Tb文件与60进制的相差不大，把例化语句里的源文件名称修改下就好，我也不再重复贴上去了。 12345678910111213141516171819202122232425262728293031323334353637383940-------------------------创建时间：2017.10.20 -创建人：Robin -文件名：counter24 -----------------------`timescale 1ns / 1psmodule counter24(input clk,clear,load,en, //时钟，清零，置数，使能input [3:0]dl,dh, //输入output reg [3:0] ql,qh, //输出output cout //进位 ); always @(posedge clk,negedge clear) //清零 if(!clear) begin ql&lt;=0;qh&lt;=0; end else if(load) begin ql&lt;=dl; //置数 qh&lt;=dh; end else if(en) if(ql==4&apos;h3 &amp;&amp; qh==4&apos;h2) begin qh&lt;=0; ql&lt;=0; end else if(ql==4&apos;h9&amp;&amp;(qh==4&apos;h1||qh==4&apos;h0)) begin qh&lt;=qh+1; ql&lt;=0; end else ql&lt;=ql+1; else ql&lt;=ql; assign cout=(en==1&apos;b1 &amp;&amp; qh==4&apos;d2 &amp;&amp; ql==4&apos;d3)?1&apos;b1:1&apos;b0;endmodule 代码的写法有很多，各有优劣，我这也只是给出一种解决办法，有错误请斧正，欢迎大家在评论区与我交流。 本文完。","categories":[{"name":"搞硬件","slug":"搞硬件","permalink":"http://www.luheng.online/categories/搞硬件/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://www.luheng.online/tags/FPGA/"}]},{"title":"半导体致冷原理与实例","slug":"半导体致冷原理与实例","date":"2017-05-26T14:04:20.000Z","updated":"2017-12-30T11:42:17.356Z","comments":true,"path":"2017/05/26/半导体致冷原理与实例/","link":"","permalink":"http://www.luheng.online/2017/05/26/半导体致冷原理与实例/","excerpt":"如果你之前没有听说过’半导体致冷’，甚至对半导体都很陌生，那么相信这篇文章是能让你“涨姿势”的,本篇文章将通过讲诉一个小冰箱的制作过程，分析它的工作原理，让大家对半导体致冷有个大体认识。夏日炎炎，为何不让半导体帮你清凉一下？","text":"如果你之前没有听说过’半导体致冷’，甚至对半导体都很陌生，那么相信这篇文章是能让你“涨姿势”的,本篇文章将通过讲诉一个小冰箱的制作过程，分析它的工作原理，让大家对半导体致冷有个大体认识。夏日炎炎，为何不让半导体帮你清凉一下？看到标题你或许会疑问什么是半导体？半导体怎么致冷？对此一无所知情况下，这些问题肯定会困扰着你，接下来让我们一起解答它，开始画知识点。 什么是半导体？我们知道任何物质都是由原子组成，原子是由原子核和电子组成。电子以高速度绕原子核转动，受到原子核吸引，因为受到一定的限制，所以电子只能在有限的轨道上运转，不能任意离开，而各层轨道上的电子具有不同的能量(电子势能)。离原子核最远轨道上的电子，经常可以脱离原子核吸引，而在原子之间运动，叫导体。如果电子不能脱离轨道形成自由电子，故不能参加导电，叫绝缘体。半导体导电能力介于导体与绝缘体之间，叫半导体。 半导体制冷原理制冷片外观和结构介绍下方两个图中，分别是制冷片的典型结构 和制冷片的常见外观 制冷器是由许多N型和P型半导体之颗粒互相排列而成，而NP之间以一般的导体相连接而成一完整线路，通常是铜、铝或其它金属导体，最后由两片陶瓷片像夹心饼干一样夹起来，陶瓷片必须绝缘且导热良好，外观如下图所示，看起来像三明治。 介绍完它的结构，那它是如何工作的？接下来说说它的现在说说它的工作原理。 制冷片的工作原理半导体热电偶由N型半导体和P型半导体组成。N型材料有多余的电子，有负温差电势。P型材料电子不足，有正温差电势；当电子从P型穿过结点至N型时，结点的温度降低，其能量必然增加，而且增加的能量相当于结点所消耗的能量。相反，当电子从N型流至P型材料时，结点的温度就会升高。 这样，半导体元件可以用各种不同的连接方法来满足使用者的要求。把一个P型半导体元件和一个N型半导体元件联结成一对热电偶，接上直流电源后，在接头处就会产生温差和热量的转移。 当电流方向是从N至P，温度下降并且吸热，这就是冷端；而当电流方向是从P至N，温度上升并且放热，因此是热端。 因此是半导体制冷片由许多N型和P型半导体之颗粒互相排列而成，而N／P之间以一般的导体相连接而成一完整线路，通常是铜、铝或其他金属导体，最後由两片陶瓷片像夹心饼乾一样夹起来，陶瓷片必须绝缘且导热良好。 单纯看了这几句话相信依旧会很模糊，下面关于一些难点进行解答。 疑难解答电能是如何“搬运”热量的？不少朋友在看过上面的文字后或许已经提出了能量守恒解释的论点。而实际上，半导体制冷并没有想象中的简单。这从技术理论的提出到真正的实际应用所用的时间就能看出来。人们常常将电流比喻成水流，电源就像水泵，不断的将低电势的电荷“搬运”至高电位，而产生的电动势驱动电荷定向移动。 而能量的形势也是多种多样的，粒子不但具有电势能，同时还具有热能等各种能量。在能量的不断转换中，各种能量以不同的方式进行转换。在珀尔帖效应中，如果使用的是半导体，那么半导体中的“自由电子”（相信高中物理学已经说得很透彻，金属的导电性和导热性都是通过“自由电子”作用的）将会在不同导体间的节点处通过电势能转换热量（放热或者吸热），而其具体表现就是制冷片的制冷效果。而半导体中的电动势解析就必须涉及更多的专业知识了。 细说N型/P型半导体N型半导体如果在锗或硅中均匀掺杂五价元素，由于价电子间会互相结合而形成共价键，故每个五价元素会与邻近四价之锗或硅原子互成一共价键，而多出一个电子来，如图(4)所示，这就称为N型半导体。(N表示negative，电子带负电) 。 由于加入五甲元素后会添加电子，故五价元素又被称为施体原子。 加入五价元素而产生之自由电子，在N型半导体里又占大多数，故称为多数载体(majority carriers) 。由温度的引响所产生之电子─电洞对是少数，所以N型半导体中称电洞为少数载体(minority carriers) 。 P型半导体如果在锗或硅中均匀掺杂三价元素，由于价电子间会互相结合而形成共价键，故每个三价元素会与邻近四价之锗或硅原子互成一共价键，而多缺少一个电子，在原子中造成一个空缺来，这个空缺我们称为电洞，如图(5)B 所示，加入三价元素之半导体就称为P型半导体。(P表示positive，电洞视为正电荷) 。 由于加入三价元素后会造成一个空缺，故三价元素又被称为受体原子。 加入三价元素而产生之电洞，在P型半导体中是多数载体。受热使共价键破坏而产生的电子电洞为少数，故P型半导体中称电子为少数载体。 通常我们都用正电荷代表电洞。但侍体中的原子不能移动，所以电洞(一个空位)也应该是不能移动的。 半导体制冷的三大效应这三大效应深究下去都是一门学问，这里不展开，只是为了让大家对半导体制冷有更深的认识。 百度百科版解释 塞贝克效应 珀尔帖效应 汤姆逊效应 英语好的朋友建议看维基百科版解释 SEEBECK EFFECT PELTIER EFFECT THOMSON EFFECT 以上是解释半导体制冷的原理介绍，说实在这样的解释我自己不满意，很多知识点都是云里雾里，但通俗易懂的说句 电流流过热电偶，发生热电效应，能量发生了转移，所以导致一端冷一端热 这样的说法又过于笼统，我尽可能解释到这里，大家就当是科学小知识看待吧。 实例：半导体冰箱的制作再次配图： 如图所示，图中的电路应该说是特别特别简单的了一个电源（12V）加上一个制冷片。实际上我所制作的半导体冰箱制冷部分就是这么弄的。 特别特别的轻松就把它连上了，然后一边凉一边热，貌似就这样成功了。虽然成功，但提醒下大家，这个电路并不实用，另外，注意保护制冷片，它不经摔。 冷热隔离单纯的这样制作显然是不行的，哪有那么容易。冷和热混在一起，不会成为冰箱的，我们所以需要将冷热分开，如何分开？用导体将冷热分离，让相互难以影响，导体实际上就是铝片和铜片。分开后，要防止它们又在一起啊，所以就需要隔离，比较粗糙的做法就是中间就加个板子。但是这样就完成了吗？ 处理多余热量没有，冷的一端我们利用了，变成冰箱。但是热的一端呢？不管它？那是不可以的，那样它会”发火”，因为不断地有热量进来，铜片的温度就会增加，然后就会有很大的安全问题，如何解决？加上两个风扇，把热量吹走。 添加温控这样是不是就可以了呢? 应该说基本功能完成。你可以看到导冷片结冰了。但这并不实用，制冷的温度不确定，是十分影响平时的使用。所以我加上了温控。 关于温控，基本原理就是利用传感器检测，AD转换后交给单片机处理，根据程序的设定，有上、下限温度，温度高于一定温度时，接通电源，制冷片工作，低于一定温度时，断开电源，制冷片不工作，讲的最简单就是这样了，实际自己制作难度不小。 至于控制电源的部分，利用了继电器的原理，因为单片机常用的电压是+5V，而制冷片的工作电压一般是+12V。必须转换。 如何检测温度，下面给出仿真图,原理这里不解释，比较复杂。 一个小冰箱的基本部件就是这些，关于其中的器件，个人认为如果从实用的角度出发，还是购买合成器件使用为宜，比较稳定且不易损坏，当然其中原理是需要仔细弄懂的，最好能仿真出来，这才是DIY的乐趣。如果你也有兴趣制作，欢迎和我交流。","categories":[{"name":"搞硬件","slug":"搞硬件","permalink":"http://www.luheng.online/categories/搞硬件/"}],"tags":[{"name":"半导体致冷","slug":"半导体致冷","permalink":"http://www.luheng.online/tags/半导体致冷/"}]},{"title":"一个故事告诉你比特币的原理及运作机制（转载）","slug":"一个故事告诉你比特币的原理及运作机制（转载）","date":"2017-05-13T07:51:17.000Z","updated":"2017-12-30T12:15:21.597Z","comments":true,"path":"2017/05/13/一个故事告诉你比特币的原理及运作机制（转载）/","link":"","permalink":"http://www.luheng.online/2017/05/13/一个故事告诉你比特币的原理及运作机制（转载）/","excerpt":"周末花时间看了一些比特币原理相关的资料，虽然不敢说把每个细节都完全搞懂了，不过整体思路和关键部分的主要原理还是比较明白。写一篇文章分享给大家。这篇文章的定位会比较科普，尽量用类比的方法将比特币的基本原理讲出来。这篇文章不会涉及算法和协议中比较细节的部分，打算后面会再写一篇程序员视角下的比特币原理，那里会从技术人员的视角对比特币系统中较为关键的数据结构、算法和协议进行一些讲解。","text":"周末花时间看了一些比特币原理相关的资料，虽然不敢说把每个细节都完全搞懂了，不过整体思路和关键部分的主要原理还是比较明白。写一篇文章分享给大家。这篇文章的定位会比较科普，尽量用类比的方法将比特币的基本原理讲出来。这篇文章不会涉及算法和协议中比较细节的部分，打算后面会再写一篇程序员视角下的比特币原理，那里会从技术人员的视角对比特币系统中较为关键的数据结构、算法和协议进行一些讲解。在这篇文章中我会给出一个虚拟的村庄叫“比特村”，整个文章会以讲故事的方式，逐步告诉大家比特币提出的动机、解决了什么问题以及一些关键组件的目标和设计方案。 问题的提出我们先从比特币产生的动机开始。 以物易物的比特村话说在这个世界上，有一个叫比特村的小村庄，村庄共有几百户人家。这个村庄几乎与世隔绝，过着自给自足的生活。由于没有大规模贸易，比特村村民一直 过着以物易物的生活，也就是说村民之间并没有使用统一的货币，互相间的贸易基本上就是老张家拿一袋面粉换老李家一只羊，王大嫂拿一筐野果换刘大婶两尺布。 村民们一直就这么纯朴的生活着。 实物货币终于有一天，村民觉得一直这样以物易物实在太不方便了，于是村子全员开会，讨论如何解决这个问题。有人提议，以便于分割且稀有的东西，例如黄金，作为一般等价物，把其它物品和黄金的对应关系编成一张表格，例如一克黄金对应一只羊，一克黄金对应一袋面粉等等，此时老张再也不用扛着一袋面粉气喘吁吁的去老李家换羊了，他只要从家里摸出一克金子，就可以去老李家牵回一只羊，而老李拿着这一克黄金可以从任何愿意出让面粉的人那里换回一袋面粉，当然也可以换取 任何和一克黄金等值的物品。 此时比特村进入了实物货币时代。 符号货币好景不长，过了一段时间，实物货币的弊端也出现了。 因为比特村附近金矿并不多，开采和冶炼金子太费时费力了。而随着使用，金子总是不断会因为磨损、 丢失或有人故意囤积而发生损耗。全村人又一次坐在了一起，开始商讨对策。 此时有人说，其实大家也不必一定要真的用黄金啊，随便找张纸，写上“一克黄金”， 只要全村人都认同这张纸就等于一克黄金，问题不就解决了。其他人纷纷表示认同，但同时也有了新的问题：真实的黄金是需要开采和冶炼的，金矿有限，开采和冶炼也需要成本，所以没有人可以短期凭空制造大量的黄金，可写字就不同了，只要我纸够笔够，随便像写多少写多少，那这就变成拼谁家里纸多了，搞不好到时一万 张纸才能换一只羊（实际上这就发生了经济学上的通货膨胀）。 大家一想也是啊。不过此时又有人提出了解决方案：这个纸不是谁写都有效，我们只认村里德高望重的老村长写得，大家都认识老村长的字。老村长写一些纸，同时按照各家黄金存量发给大家等量的纸，例如老张家有二百克黄金，老村长就发给老张二百张写着“一克黄金”的纸，同时将老张家的黄金拿走作为抵押。就这样，老村长将村里所有黄金收归到自己的家里，并按各家上交的黄金数量发给等值的写有字的纸。此时村民就可以拿着这些纸当黄金进行贸易了，而且大家都认得 老村长的字，其他人伪造不出来。另外，如果谁的纸磨损太严重，也可拿到老村长那里兑换新的等值的纸，另外老村长承诺任何人如果想要换成真黄金，只要拿纸回 来，老村长就会把等值的黄金还给那人。因为老村长写得纸的黄金量和真实放在家里的黄金量是一样的，所以只要严格按照销毁多少纸新写多少纸的原则，每一张有效的纸总能换回相应的真黄金。 此时，比特村进入了符号货币（纸币）时代。而老村长就承担了政府和银行的角色。 中央系统虚拟货币又过了几年，老村长由于每天都要核对大量的旧纸币，写新的纸币，还要把各种账目仔细做好记录。一来二去，老村长操劳过度不幸驾鹤西去了。 比特村再次召开全体大会，讨论应该怎么办。此时老村长的儿子二狗子自告奋勇接过了父亲的笔，承担起货币发行的责任。这个年轻的村长二狗子很聪明，他做了几天，发现好像也不用真的写那么多纸。完全可以这样：村民把纸币都交上来，销毁，但是二狗子会记录下每户上交的纸币数量。以后如果要进行付钱，例如老张要拿一克金子向老李换一只羊，就一起给二狗子打个电话，说明要将老张名下的一克金子划归老李名下，二狗子拿出账本，看看老张名下是否有一克金子，如果有，就在老账的名下减掉一克，在老李的名下加上一克，这样就完成了支付，此时老李在电话中听到二狗子确认转账完成，就可以放心让老张把羊牵走了。 此时比特村进入了中央系统虚拟货币时代。每个村民都不需要用实物支付，支付过程变成了二狗子那边维护的账本上数字的变更。 分布式虚拟货币这新上任的二狗子是聪明，不过这人有时候是聪明反被聪明误。有一天二狗子盯着这账本，心想这全村各户谁有多少钱就是我说的算，那我岂不是……。于是他头脑一热，私自从老张帐下划了十克金子到自己名下。 本以为天衣无缝，但没想到老张也有记账的习惯，有一天他正要付钱却被二狗子告知账户没钱了。老账核对了一下自己的账本，明明还有十克啊，于是拿着账本去找二狗子理论，这一核对发现了那笔未经老张同意的转账。 东窗事发！比特村炸开锅了。二狗子被弹劾是不可避免了，不过通过这件事，大家发现了账本集中在一个人手里的弊端： 这个体系完全依赖于账本持有人的个人信用，如果这个人不守规矩，随意篡改账本，那么整个货币系统就会崩溃 如果这个人家里失火或者账本失窃，同样也会为整个体系带来毁灭性的打击。 正当人们不知所措时，村里一个叫中本聪的宅男科学家走上了台，告诉大家他已经设计了一套不依赖任何中央处理人的叫比特币的虚拟货币系统，可以解决上述问题。然后他缓缓讲述了自己的方案。 下面我们就来看看中本聪同学是如何设计这套系统的。 基础设施搭建账簿公开机制中本聪首先说明，要对现有账簿进行如下改造： 账簿上不再记载每户村民的余额，而只记载每一笔交易。即记载每一笔交易的付款人、收款人和付款金额。只要账簿的初始状态确定，每一笔交易记录可靠并有时序，当前每个人持有多少钱是可以推算出来的。 账簿由私有改为公开，只要任何村民需要，都可以获得当前完整的账簿，账簿上记录了从账簿创建开始到当前所有的交易记录。 此言一出，下面立刻炸锅了。第一条还无所谓，但是第二条简直无法接受，因为账簿可是记录了所有村民的交易，这样大家的隐私不全暴露了吗。 中本聪倒是不慌不忙，拿出了一对奇怪的东西。 身份与签名机制（公钥加密系统）中本聪说，大家不要慌。在他的这套机制下，任何人都不使用真实身份交易，而是使用一个唯一的代号交易。 他展示了手里神奇的东西，说这两件东西分别叫保密印章和印章扫描器。后面他会给村里每一户发一个保密印章和一个印章扫描器。两者的作用如下： 保密印章可以在纸上盖一个章，每个印章盖出的章都隐含了一个全村唯一的一串字符，但是凭肉眼是看不出来的。也无法通过观察来制造出相应的印章 印章扫描器可以扫描某个已经盖好的章，读出隐含的信息，并在液晶屏上显示出一串字符 有了这两个神奇的东西，大家就可以在不暴露真实身份的情况下进行交易了，而印章隐含的那一串字符就是这户人家的代号。具体如何巧妙利用保密印章和印章扫描器进行交易，会在下文详述。 成立虚拟矿工组织（挖矿群体）下一步，中本聪面向全村招募虚拟矿工，招募要求如下： 矿工以组为单位，一组可以是单独的一户，也可以是几户联合为一组 成为矿工不影响正常使用货币 矿工每天要花费一定时间从事比特币“挖矿”活动，但是不同于挖金矿，虚拟矿工不需要拿着工具去野外作业，在家里就可以完成工作 矿工有一定可能性获得报酬，在挖矿活动中付出的努力越多，获得报酬的可能性越大 矿工可以随时退出，也可以随时有新的矿工加进来 很快，大约有五分之一的村民加入比特币矿工组织，共分成了7个组。 建立初始账簿（创世块）下面，中本聪宣布，先根据二狗子手里的账簿，把抵押的所有黄金按账簿记录的余额退还给每位村民，然后彻底销毁这本账簿。 然后，中本聪拿出一本新账簿，在账簿的第一页上记录了一些交易记录，特别的是，这些记录的付款人一栏全都是“系统”，而收款人分别是每个印章对应的隐含字符，代表初始时刻，系统为每一户默认分配了一定数量比特币，但是数量非常少，都只有几枚，甚至有些不幸的村户没有获得比特币。 接着中本聪说，由于目前市面上比特币非常少，大家可以先回到用黄金做货币的时代，由于我不是村长，我也没有权利强迫大家一定要承认比特币，大家可以自行决定要不要接受比特币。不过随着比特币的流动和矿工的活动，比特币会慢慢多起来。 支付与交易做了这么多铺垫，终于说到重点了，下面说一下在这样一个体系下如何完成支付。以老张付给老李10个比特币为例。 付款人签署交易单为了支付10个比特币，老张首先要询问老李的标识字符串，例如是“ABCDEFG”，同时老张也有一个标识字符串例如是“HIJKLMN”，然后老 张写一张单子，内容为“HILKLMN支付10比特币给ABCDEFG”，然后用自己的保密印章改一个章，将这张单子交给老李。另外为了便于追溯这笔钱的来源，还要在单子里注明这笔钱的来源记在哪一页，例如这个单子里，老张的10比特币来自建立账簿时系统的赠送，记录在账簿第一页。 收款人确认单据签署人老李拿到这个单子后，需要确认这个单子确实是来自“HIJKLMN”这个人（也就是老张）签署的，这个并不困难。因为单子上必须有保密章，老李拿出印章扫描器，扫一下章，如果液晶屏显示出的字符和付款人字符是一致的（这里是“HIJKLMN”），就可以确认单子确实是付款人签署的。这是因为根据保密印章的机制，没有其他人可以伪造印章，任何一个人只要扫描一下印章，都可以确认单子的付款人和盖章人是否一致。 收款人确认付款人余额这个系统到目前还是很有问题。通过保密印章，收款人虽然可以确认付款人确实签署了这份单子，但是无法自行确认付款人是否有足够的余额支付。之前的中央虚拟货币系统中，二狗子负责检查付款人的余额，并通知收款人交易是否有效，现在把二狗子开了，谁来负责记账和确认每笔交易的有效性呢？ 之前说过，中本聪设计的这个系统是分布式货币系统，不依赖任何中央人物，所以不会有一个或少数几个人负责这件事，最终承担这份工作的是之前所提到的矿工组织。老张、老李和全村其他任何使用比特币进行交易的村民都依赖矿工组织的工作才能完成交易。 矿工的工作矿工的工作是整个系统的核心，也是最复杂性最高的地方。下面逐步介绍矿工的工作内容和目的。 矿工的工具俗话说，工欲善其事，必先利其器。比特币矿工虽然不用铁撅、铁锨和探照灯等工具，不过也要有一些必备的东西。初始账簿。每个组首先自己复制一份初始账簿，初始账簿只有一页，记录了系统的第一次赠送。每个小组有若干账簿纸，每一页纸上仅有账簿结构，没有填内容，具体内容的书写规则后面讲述。下面是一张空账簿纸的样子，各个字段的意义后面会说到。 编码生成器（哈希函数）。中本聪又向矿工组织的每个组分发了若干编码生成器，这个东西很神奇，将一页账簿填好内容的账簿纸放入这个机器，机器会在账簿纸的“本账单编号”一栏自动打印一串由“0”和“1”组成的编号，共256个。最神奇的是，编号生成器有如下功能： 生成的编号仅与账簿纸上填入的内容有关，与填写人、字体、填写时间等因素均无关。 内容相同的账簿纸生成的编号总是相同，但是如果内容哪怕只改一个字符，编号就会面目全非。 编码生成器在打印编码时还需要将所有填入账簿纸的交易单放入，机器会扫描交易单和填入交易单的一致性，尤其是保密印章，如果发现保密印章和付款人不一致，会拒绝打印编码。 将一张已打印的账簿纸放入，机器会判定编号是否是有效的机器打印，并且判定编号和内容是否一致，这个编号无法伪造。 交易单收件箱。每个矿工小组需要在门口挂一个箱子用于收集交易单。 公告板。每个矿工小组同样需要一个公告板公示一些信息。 有了上面的工具，矿工组织就可以开工了！ 收集交易单中本聪规定，每笔交易的发起人，不但要将交易单给到收款人，还要同时复制若干份一模一样的交易单投递到每个矿工小组的收件箱里。 矿工小组的人定期到自己的收件箱里把收集到的交易单一并取出来。 填写账簿此时小组的人拿出一张空的账簿纸，把这些交易填写到“交易清单”一栏，同时找到当前账簿最后一页，将最后一页的编号抄写到“上一张账单编号一栏”。注意还有个“幸运数字”，可以随便填上一个数字，如12345。然后，将这样账簿纸放入编号生成器，打印好编号，一张账簿就算完成了。 如果你以为矿工的工作就这么简单，那就大错特错了，中本聪有个变态的规定：只有编号的前10个数均为0，这页账簿纸才算有效。 根据之前对编号生成器的描述，要修改编号，只能修改账簿纸的内容，而“交易清单”和“上一张账簿纸编号”是不能随便改的，那么只能改幸运数字了。于是为了生成有效的账簿纸，小组里的矿工就不断抄写账簿纸，但每张纸的幸运数字都不同，然后不断的重复将纸放入编码器，如果生成的编号不符合规定，这张纸就算废了，重复这个过程直到生成一串有效的编号。 我们知道，如果编号的每一个数字都是随机的，那么平均写1000多张幸运数字不同的纸才能获得一个有效的编号。 这就奇怪了，这些矿工为什么要拼命干这看似无意义的事情呢？还记得之前说过矿工有报酬吧，这就是矿工的动力了。中本聪规定：每一张账簿纸的交易清单 第一条交易为“系统给这个小组支付50个比特币”。也就是说，如果你生成了一张有意义的账簿纸，并且被所有挖矿小组接受了，那么就意味着这条交易也被接受 了，你的挖矿小组获得了50个比特币。 这就是矿工被叫做矿工的原因，也是为什么之前说随着交易和矿工的活动，比特币的数量会不断增多。例如下面是一个挖矿过程，这个小组的公共比特币帐号为“UVWXYZ”。 在幸运数字尝试到“533”时，系统生成了一页有效账簿。 确认账簿当某挖矿小组幸运的生成了一张有意义的账簿，为了得到奖励，必须立刻请其它小组确认自己的工作。前面说过，当前村里有7个挖矿组，所以这个小组必须将有效账簿纸誊抄6份快马加鞭送到其他6个小组请求确认。 中本聪规定，当某个小组接到其他小组送来的账簿纸时，必须立即停下手里的挖矿工作进行账簿确认。 需要确认的信息有三个： 账簿的编号有效 账簿的前一页账簿有效 交易清单有效 首先看第一个，这个确认比较简单。只要将送来的账簿纸放入编码生成器进行验证，如果验证通过，则编号有效。 第二部分需要将账簿页上的“上一页账簿纸编号”和这个小组目前保存的有效账簿最后一页编号比对，如果相同则确认，如果不同，需要顺着已有账簿向前比对，直到找到这个编号的页。如果没有找到指定的“上一页账簿纸编号”对应的页，这个小组会将此页丢掉。不予确认。 注意，由上面的机制可以保证，如果各个小组手里的账簿纸是相同的，那么他们都能按同样的顺序装订成相同的账簿。因为后面一张纸的编号总是依赖前面的纸的编号，编码生成器的机制保证了所有合法账簿纸的相对先后顺序在每个小组那里都是相同的（可能会有分支，但不会出现环，后面细讲）。 最后是如何确认交易清单有效，其实也就是要确认当前每笔交易的付款人有足够的余额支付这笔钱。由于交易信息里包含这笔钱是如何来的，还包含了记录来 源交易的账单编号。例如，HIJKLMN要给ABCDEFG10个比特币，并注明了这10个比特币来自之前OPQRST支付给HIJKLMN的一笔交易，确认时首先要确认之前这笔交易是否存在，同时还要检查HIJKLMN在这之前没有将这10个比特币支付给别人。这一切确认后，这笔交易有效性就被确认了。 其中第一笔是系统奖励给生成这页账簿的小组的50个，这笔交易大家都默认承认，后面的只要按照上述方法追溯，就可以确认HIJKLMN是否当前真有10个比特币支付给ABCDEFG。 如果完成了所有了上述验证并全部通过，这个小组就认可了上述账簿纸有效，然后将这张账簿纸并入小组的主账簿，舍弃目前正在进行的工作，后面的挖矿工作会基于这本更新后的主账本进行。 账簿确认反馈对于挖矿小组来说，当账簿纸送出去后，如果后面有收到其他小组送来的账簿纸，其“上一页账簿纸编号”为自己之前送出去的账簿纸，那么就表示他们的工作成功被其他小组认可了，因为已经有小组基于他们的账簿纸继续工作了。此时，可以粗略的说可以认为已经得到了50个比特币。 另外，任何一个小组当新生成有效账簿纸或确认了别的小组的账簿纸时，就将最新被这个小组承认的交易写到公告牌上，那么收款人只要发现相关交易被各个小组认可了，基本就可以认为这笔钱已经到了自己的账上，后面他就可以在付款时将钱的来源指向这笔交易了。 以上就是整个比特币的支付体系。下面我们来分析一下，这个体系为什么可以工作下去，以及这个体系可能面临的风险。 工作机制分析虽然上面阐述了比特币的基本运作规则，但是村民们还是有不少疑问。所以中本聪同学专门开了个答疑会，解答常见问题。下面总结一下村民最集中关心的问题。 核心问题答疑如果同时收到两份合法的账簿页怎么办？注意在上面的运行机制中，各个挖矿小组是并行工作的，因此完全可能出现这样的情况：某小组收到两份不一样的账簿页，它们都基于当前这个小组的主账簿的最后一页，并且内容也都完全合法，怎么办？ 关于这个问题，中本聪同学说，小组不应该以线性方式组织账簿，而应该以树状组织账簿，任何时刻，都以当前最长分支作为主账簿，但是保留其它分支。举个例子，某小组同时收到A、B两份账簿页，经核算都是合法的，此时小组应该将两页以分叉的形式组织起来，如下图所示： 黑色表示当前账簿主干。此时，可以随便选择一个页作为当前主分支，例如选择A： 此时如果有一个新的账簿页是基于A的，那么这个主干就延续下去： 如果这个主干一直这么延续下去，表示大家基本都以A为主干，B就会被遗忘。但是也有可能忽然B变成更长了： 那么我们就需要将B分支作为当前主干，基于这个分支进行后续工作。 从局部来看，虽然在某一时刻各个小组的账簿主干可能存在不一致，但大方向是一致的，那些偶尔由于不同步产生的小分支，会很快被淹没在历史中。 如果挖矿小组有人伪造账簿怎么办关于这个问题，中本聪同学说，只要挖矿组织中大多数人是诚实的，这个系统就可靠，具体分几个方面给予答复。 首先，基于保密印章机制，没有人能伪造他人身份进行付款，因为编码生成器在打印编码时会核对所有交易单的保密印章，印章和付款人不一致会拒绝打印。 而且诚实的矿工也不会承认不合法的交易（如某笔交易付款方余额不够）。 所以只有一种可能的攻击行为，即在收款人确认收款后，从另一条分支上建立另外的交易单，取消之前的付款，而将同一笔钱再次付款给另一个人（即所谓的double-spending问题）。下面同样用一个例子说明这个问题。 先假设有一个攻击者拥有10个比特币，他准备将这笔钱同时支付给两名受害者A和B，并都得到承认。 第一步，攻击者准备从受害者A手里买10比特币的黄金，他签署交易单给受害者A，转10个比特币给受害者A。 第二步，这笔交易在最新的账簿页中被确认，并被各个挖矿小组公告出来。受害人A看到公告，确认比特币到账，给了攻击者10个比特币等值的黄金。 第三步，攻击者找到账簿，从包含刚才交易的账簿页的前一页做出一个分支，生成更多的账单页，超过刚才的分支。由于此时刚才攻击者制造的分支变成了主干分支，而包含受害者A得到钱的分支变成了旁支，因此挖矿组织不再承认刚才的转账，受害者A得到的10比特币被取消了。 第四步，攻击者可以再次签署交易单，将同一笔钱支付给受害者B。受害者B确认钱到账后，支付给攻击者等值黄金。 至此，攻击者将10个比特币花了两次，从两名受害者那里各购得等值黄金。攻击者还可以如法炮制，取消与受害者B的转账，将同一笔钱再支付给其他人。 关于这种攻击，中本聪给出的解决方案是，建议收款人不要在公告挂出时立即确认交易完成，而是应该再看一段时间，等待各个挖矿小组再挂出6张确认账簿，并且之前的账簿没有被取消，才确认钱已到账。 中本聪解释道，之前设定变态的编号规则，正是为了防御这一点。根据前面所述，生成有效账簿页不是那么简单的，要花费大量的人力反复试不同的幸运数字，而且过程完全是碰运气。如果某账簿页包含你收到钱的确认，并且在后面又延续了6个，那么攻击者想要在落后6页的情况下从另一个分支赶超当前主分支是非常困难的，除非攻击者拥有非常多的人力，超过其他所有诚实矿工的人力之和。 而且，如果攻击者有如此多人力，与其花这么大力气搞这种攻击，还不如做良民挖矿来的收益大。这就从动机上杜绝了攻击的形成。 比特币会一直增加下去，岂不是会严重通货膨胀中本聪说，这一点我也想到了。前面忘了说了，我给矿工组织的操作细则手册会说明，刚开始我们协议每生成一页账簿，奖励小组50个比特币，后面，每当 账簿增加21,000页，奖励就减半，例如当达到210,000页后，每生成一页账簿奖励25个比特币，420,000页后，每生成一页奖励12.5个， 依次类推，等账簿达到6,930,000页后，新生成账簿页就没有奖励了。此时比特币全量约为21,000,000个，这就是比特币的总量，所以不会无限 增加下去。 没有奖励后，就没人做矿工了，岂不是没人帮忙确认交易了到时，矿工的收益会由挖矿所得变为收取手续费。例如，你在转账时可以指定其中1%作为手续费支付给生成账簿页的小组，各个小组会挑选手续费高的交易单优先确认。 矿工如果越来越多，比特币生成速度会变快吗不会。中本聪解释，虽然可以任意加入和退出矿工组织，导致矿工人数变化，每个矿工也会拿到一个编码生成器，不过我已经在编码生成器中加入了调控机制，当前工作的编码生成器越多，每个机器的效率就越低，保证新账簿页生成速率不变。 虽然每个人的代号是匿名的，但如果泄露了某个人的代号，账簿又是公开的，岂不是他的所有账目都查出来了 确实是这样的。例如你要和某人交易，必然要要到他的代号才能填写交易单。因为收款人一栏要填入那人的代号。不过中本聪说可以提供无限制的保密印章，建议每一次交易用不同的保密印章，这样查账簿就追查不到同一个人的所有账目了。答疑完毕。 说明本文用通俗比喻的方式讲解了比特币的运行机制。有几点需要说明： 为了便于理解，我做了很多简化，因此有些机制细节和实际的比特币可能不完全相同。但总体思想和关键原理是一致的。 由于很多计算机世界的东西（如公钥体系、网络传输）在现实世界中并没有特别好的对等物，所以故事里难免有一些生硬和不合常理的细节。 本文描述的是比特币网络本身的技术原理和运作机制，当在如Mtgox这种买卖市场中进行比特币交易时，市场做了中间代理，并不遵从上述机制。","categories":[{"name":"搞娱乐","slug":"搞娱乐","permalink":"http://www.luheng.online/categories/搞娱乐/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"http://www.luheng.online/tags/比特币/"}]},{"title":"傅里叶分析之掐死教程（转载）","slug":"傅里叶分析之掐死教程（转载）","date":"2017-04-19T10:30:52.000Z","updated":"2017-12-30T12:14:59.966Z","comments":true,"path":"2017/04/19/傅里叶分析之掐死教程（转载）/","link":"","permalink":"http://www.luheng.online/2017/04/19/傅里叶分析之掐死教程（转载）/","excerpt":"这篇文章的核心思想就是：要让读者在不看任何数学公式的情况下理解傅里叶分析。","text":"这篇文章的核心思想就是：要让读者在不看任何数学公式的情况下理解傅里叶分析。傅里叶分析不仅仅是一个数学工具，更是一种可以彻底颠覆一个人以前世界观的思维模式。但不幸的是，傅里叶分析的公式看起来太复杂了，所以很多大一新生上来就懵圈并从此对它深恶痛绝。老实说，这么有意思的东西居然成了大学里的杀手课程，不得不归咎于编教材的人实在是太严肃了。（您把教材写得好玩一点会死吗？会死吗？）所以我一直想写一个有意思的文章来解释傅里叶分析，有可能的话高中生都能看懂的那种。所以，不管读到这里的您从事何种工作，我保证您都能看懂，并且一定将体会到通过傅里叶分析看到世界另一个样子时的快感。至于对于已经有一定基础的朋友，也希望不要看到会的地方就急忙往后翻，仔细读一定会有新的发现。————以上是定场诗———— 下面进入正题：抱歉，还是要啰嗦一句：其实学习本来就不是易事，我写这篇文章的初衷也是希望大家学习起来更加轻松，充满乐趣。但是千万！千万不要把这篇文章收藏起来，或是存下地址，心里想着：以后有时间再看。这样的例子太多了，也许几年后你都没有再打开这个页面。无论如何，耐下心，读下去。这篇文章要比读课本要轻松、开心得多…… p.s.本文无论是cos还是sin，都统一用“正弦波”（Sine Wave）一词来代表简谐波。 一、什么是频域从我们出生，我们看到的世界都以时间贯穿，股票的走势、人的身高、汽车的轨迹都会随着时间发生改变。这种以时间作为参照来观察动态世界的方法我们称其为时域分析。而我们也想当然的认为，世间万物都在随着时间不停的改变，并且永远不会静止下来。但如果我告诉你，用另一种方法来观察世界的话，你会发现世界是永恒不变的，你会不会觉得我疯了？我没有疯，这个静止的世界就叫做频域。先举一个公式上并非很恰当，但意义上再贴切不过的例子：在你的理解中，一段音乐是什么呢？这是我们对音乐最普遍的理解，一个随着时间变化的震动。但我相信对于乐器小能手们来说，音乐更直观的理解是这样的：好的！下课，同学们再见。是的，其实这一段写到这里已经可以结束了。上图是音乐在时域的样子，而下图则是音乐在频域的样子。所以频域这一概念对大家都从不陌生，只是从来没意识到而已。现在我们可以回过头来重新看看一开始那句痴人说梦般的话：世界是永恒的。将以上两图简化： 时域： 频域： 在时域，我们观察到钢琴的琴弦一会上一会下的摆动，就如同一支股票的走势；而在频域，只有那一个永恒的音符。所以你眼中看似落叶纷飞变化无常的世界，实际只是躺在上帝怀中一份早已谱好的乐章。抱歉，这不是一句鸡汤文，而是黑板上确凿的公式：傅里叶同学告诉我们，任何周期函数，都可以看作是不同振幅，不同相位正弦波的叠加。在第一个例子里我们可以理解为，利用对不同琴键不同力度，不同时间点的敲击，可以组合出任何一首乐曲。而贯穿时域与频域的方法之一，就是传中说的傅里叶分析。傅里叶分析可分为傅里叶级数（Fourier Serie）和傅里叶变换(Fourier Transformation)，我们从简单的开始谈起。 二、傅里叶级数(Fourier Series)的频谱还是举个栗子并且有图有真相才好理解。如果我说我能用前面说的正弦曲线波叠加出一个带90度角的矩形波来，你会相信吗？你不会，就像当年的我一样。但是看看下图：第一幅图是一个郁闷的正弦波cos（x）第二幅图是2个卖萌的正弦波的叠加cos(x)+a.cos(3x)第三幅图是4个发春的正弦波的叠加第四幅图是10个便秘的正弦波的叠加随着正弦波数量逐渐的增长，他们最终会叠加成一个标准的矩形，大家从中体会到了什么道理？（只要努力，弯的都能掰直！）随着叠加的递增，所有正弦波中上升的部分逐渐让原本缓慢增加的曲线不断变陡，而所有正弦波中下降的部分又抵消了上升到最高处时继续上升的部分使其变为水平线。一个矩形就这么叠加而成了。但是要多少个正弦波叠加起来才能形成一个标准90度角的矩形波呢？不幸的告诉大家，答案是无穷多个。（上帝：我能让你们猜着我？）不仅仅是矩形，你能想到的任何波形都是可以如此方法用正弦波叠加起来的。这是没有接触过傅里叶分析的人在直觉上的第一个难点，但是一旦接受了这样的设定，游戏就开始有意思起来了。还是上图的正弦波累加成矩形波，我们换一个角度来看看：在这几幅图中，最前面黑色的线就是所有正弦波叠加而成的总和，也就是越来越接近矩形波的那个图形。而后面依不同颜色排列而成的正弦波就是组合为矩形波的各个分量。这些正弦波按照频率从低到高从前向后排列开来，而每一个波的振幅都是不同的。一定有细心的读者发现了，每两个正弦波之间都还有一条直线，那并不是分割线，而是振幅为0的正弦波！也就是说，为了组成特殊的曲线，有些正弦波成分是不需要的。这里，不同频率的正弦波我们成为频率分量。好了，关键的地方来了！！如果我们把第一个频率最低的频率分量看作“1”，我们就有了构建频域的最基本单元。对于我们最常见的有理数轴，数字“1”就是有理数轴的基本单元。时域的基本单元就是“1秒”，如果我们将一个角频率为的正弦波cos（t）看作基础，那么频域的基本单元就是。有了“1”，还要有“0”才能构成世界，那么频域的“0”是什么呢？cos（0t）就是一个周期无限长的正弦波，也就是一条直线！所以在频域，0频率也被称为直流分量，在傅里叶级数的叠加中，它仅仅影响全部波形相对于数轴整体向上或是向下而不改变波的形状。 接下来，让我们回到初中，回忆一下已经死去的八戒，啊不，已经死去的老师是怎么定义正弦波的吧。正弦波就是一个圆周运动在一条直线上的投影。所以频域的基本单元也可以理解为一个始终在旋转的圆。 介绍完了频域的基本组成单元，我们就可以看一看一个矩形波，在频域里的另一个模样了：这是什么奇怪的东西？这就是矩形波在频域的样子，是不是完全认不出来了？教科书一般就给到这里然后留给了读者无穷的遐想，以及无穷的吐槽，其实教科书只要补一张图就足够了：频域图像，也就是俗称的频谱，就是—— 再清楚一点： 可以发现，在频谱中，偶数项的振幅都是0，也就对应了图中的彩色直线。振幅为0的正弦波。 老实说，在我学傅里叶变换时，维基的这个图还没有出现，那时我就想到了这种表达方法，而且，后面还会加入维基没有表示出来的另一个谱——相位谱。但是在讲相位谱之前，我们先回顾一下刚刚的这个例子究竟意味着什么。记得前面说过的那句“世界是静止的”吗？估计好多人对这句话都已经吐槽半天了。想象一下，世界上每一个看似混乱的表象，实际都是一条时间轴上不规则的曲线，但实际这些曲线都是由这些无穷无尽的正弦波组成。我们看似不规律的事情反而是规律的正弦波在时域上的投影，而正弦波又是一个旋转的圆在直线上的投影。那么你的脑海中会产生一个什么画面呢？我们眼中的世界就像皮影戏的大幕布，幕布的后面有无数的齿轮，大齿轮带动小齿轮，小齿轮再带动更小的。在最外面的小齿轮上有一个小人——那就是我们自己。我们只看到这个小人毫无规律的在幕布前表演，却无法预测他下一步会去哪。而幕布后面的齿轮却永远一直那样不停的旋转，永不停歇。这样说来有些宿命论的感觉。说实话，这种对人生的描绘是我一个朋友在我们都是高中生的时候感叹的，当时想想似懂非懂，直到有一天我学到了傅里叶级数…… 三、傅里叶级数（Fourier Series）的相位谱上一章的关键词是：从侧面看。这一章的关键词是：从下面看。在这一章最开始，我想先回答很多人的一个问题：傅里叶分析究竟是干什么用的？这段相对比较枯燥，已经知道了的同学可以直接跳到下一个分割线。先说一个最直接的用途。无论听广播还是看电视，我们一定对一个词不陌生——频道。频道频道，就是频率的通道，不同的频道就是将不同的频率作为一个通道来进行信息传输。下面大家尝试一件事：先在纸上画一个sin（x），不一定标准，意思差不多就行。不是很难吧。好，接下去画一个sin（3x）+sin（5x）的图形。别说标准不标准了，曲线什么时候上升什么时候下降你都不一定画的对吧？好，画不出来不要紧，我把sin（3x）+sin（5x）的曲线给你，但是前提是你不知道这个曲线的方程式，现在需要你把sin（5x）给我从图里拿出去，看看剩下的是什么。这基本是不可能做到的。但是在频域呢？则简单的很，无非就是几条竖线而已。所以很多在时域看似不可能做到的数学操作，在频域相反很容易。这就是需要傅里叶变换的地方。尤其是从某条曲线中去除一些特定的频率成分，这在工程上称为滤波，是信号处理最重要的概念之一，只有在频域才能轻松的做到。再说一个更重要，但是稍微复杂一点的用途——求解微分方程。（这段有点难度，看不懂的可以直接跳过这段）微分方程的重要性不用我过多介绍了。各行各业都用的到。但是求解微分方程却是一件相当麻烦的事情。因为除了要计算加减乘除，还要计算微分积分。而傅里叶变换则可以让微分和积分在频域中变为乘法和除法，大学数学瞬间变小学算术有没有。傅里叶分析当然还有其他更重要的用途，我们随着讲随着提。————————————————————————————————————下面我们继续说相位谱：通过时域到频域的变换，我们得到了一个从侧面看的频谱，但是这个频谱并没有包含时域中全部的信息。因为频谱只代表每一个对应的正弦波的振幅是多少，而没有提到相位。基础的正弦波A.sin(wt+θ)中，振幅，频率，相位缺一不可，不同相位决定了波的位置，所以对于频域分析，仅仅有频谱（振幅谱）是不够的，我们还需要一个相位谱。那么这个相位谱在哪呢？我们看下图，这次为了避免图片太混论，我们用7个波叠加的图。鉴于正弦波是周期的，我们需要设定一个用来标记正弦波位置的东西。在图中就是那些小红点。小红点是距离频率轴最近的波峰，而这个波峰所处的位置离频率轴有多远呢？为了看的更清楚，我们将红色的点投影到下平面，投影点我们用粉色点来表示。当然，这些粉色的点只标注了波峰距离频率轴的距离，并不是相位。 这里需要纠正一个概念：时间差并不是相位差。如果将全部周期看作2Pi或者360度的话，相位差则是时间差在一个周期中所占的比例。我们将时间差除周期再乘2Pi，就得到了相位差。在完整的立体图中，我们将投影得到的时间差依次除以所在频率的周期，就得到了最下面的相位谱。所以，频谱是从侧面看，相位谱是从下面看。下次偷看女生裙底被发现的话，可以告诉她：“对不起，我只是想看看你的相位谱。”注意到，相位谱中的相位除了0，就是Pi。因为cos（t+Pi）=-cos（t），所以实际上相位为Pi的波只是上下翻转了而已。对于周期方波的傅里叶级数，这样的相位谱已经是很简单的了。另外值得注意的是，由于cos（t+2Pi）=cos（t），所以相位差是周期的，pi和3pi，5pi，7pi都是相同的相位。人为定义相位谱的值域为(-pi，pi]，所以图中的相位差均为Pi。最后来一张大集合： 四、傅里叶变换（Fourier Transformation）相信通过前面三章，大家对频域以及傅里叶级数都有了一个全新的认识。但是文章在一开始关于钢琴琴谱的例子我曾说过，这个栗子是一个公式错误，但是概念典型的例子。所谓的公式错误在哪里呢？傅里叶级数的本质是将一个周期的信号分解成无限多分开的（离散的）正弦波，但是宇宙似乎并不是周期的。曾经在学数字信号处理的时候写过一首打油诗：往昔连续非周期，回忆周期不连续，任你ZT、DFT，还原不回去。（请无视我渣一样的文学水平……）在这个世界上，有的事情一期一会，永不再来，并且时间始终不曾停息地将那些刻骨铭心的往昔连续的标记在时间点上。但是这些事情往往又成为了我们格外宝贵的回忆，在我们大脑里隔一段时间就会周期性的蹦出来一下，可惜这些回忆都是零散的片段，往往只有最幸福的回忆，而平淡的回忆则逐渐被我们忘却。因为，往昔是一个连续的非周期信号，而回忆是一个周期离散信号。是否有一种数学工具将连续非周期信号变换为周期离散信号呢？抱歉，真没有。比如傅里叶级数，在时域是一个周期且连续的函数，而在频域是一个非周期离散的函数。这句话比较绕嘴，实在看着费事可以干脆回忆第一章的图片。而在我们接下去要讲的傅里叶变换，则是将一个时域非周期的连续信号，转换为一个在频域非周期的连续信号。算了，还是上一张图方便大家理解吧： 或者我们也可以换一个角度理解：傅里叶变换实际上是对一个周期无限大的函数进行傅里叶变换。所以说，钢琴谱其实并非一个连续的频谱，而是很多在时间上离散的频率，但是这样的一个贴切的比喻真的是很难找出第二个来了。因此在傅里叶变换在频域上就从离散谱变成了连续谱。那么连续谱是什么样子呢？你见过大海么？为了方便大家对比，我们这次从另一个角度来看频谱，还是傅里叶级数中用到最多的那幅图，我们从频率较高的方向看。 以上是离散谱，那么连续谱是什么样子呢？尽情的发挥你的想象，想象这些离散的正弦波离得越来越近，逐渐变得连续……直到变得像波涛起伏的大海： 很抱歉，为了能让这些波浪更清晰的看到，我没有选用正确的计算参数，而是选择了一些让图片更美观的参数，不然这图看起来就像屎一样了。不过通过这样两幅图去比较，大家应该可以理解如何从离散谱变成了连续谱的了吧？原来离散谱的叠加，变成了连续谱的累积。所以在计算上也从求和符号变成了积分符号。不过，这个故事还没有讲完，接下去，我保证让你看到一幅比上图更美丽壮观的图片，但是这里需要介绍到一个数学工具才能然故事继续，这个工具就是—— 五、宇宙耍帅第一公式：欧拉公式虚数i这个概念大家在高中就接触过，但那时我们只知道它是-1的平方根，可是它真正的意义是什么呢?这里有一条数轴，在数轴上有一个红色的线段，它的长度是1。当它乘以3的时候，它的长度发生了变化，变成了蓝色的线段，而当它乘以-1的时候，就变成了绿色的线段，或者说线段在数轴上围绕原点旋转了180度。我们知道乘-1其实就是乘了两次 i使线段旋转了180度，那么乘一次 i 呢——答案很简单——旋转了90度。同时，我们获得了一个垂直的虚数轴。实数轴与虚数轴共同构成了一个复数的平面，也称复平面。这样我们就了解到，乘虚数i的一个功能——旋转。现在，就有请宇宙第一耍帅公式欧拉公式隆重登场—— 这个公式在数学领域的意义要远大于傅里叶分析，但是乘它为宇宙第一耍帅公式是因为它的特殊形式——当x等于Pi的时候。 经常有理工科的学生为了跟妹子表现自己的学术功底，用这个公式来给妹子解释数学之美：”石榴姐你看，这个公式里既有自然底数e，自然数1和0，虚数i还有圆周率pi，它是这么简洁，这么美丽啊！“但是姑娘们心里往往只有一句话：”臭屌丝……“这个公式关键的作用，是将正弦波统一成了简单的指数形式。我们来看看图像上的涵义：欧拉公式所描绘的，是一个随着时间变化，在复平面上做圆周运动的点，随着时间的改变，在时间轴上就成了一条螺旋线。如果只看它的实数部分，也就是螺旋线在左侧的投影，就是一个最基础的余弦函数。而右侧的投影则是一个正弦函数。关于复数更深的理解，大家可以参考：复数的物理意义是什么？这里不需要讲的太复杂，足够让大家理解后面的内容就可以了。 六、指数形式的傅里叶变换有了欧拉公式的帮助，我们便知道：正弦波的叠加，也可以理解为螺旋线的叠加在实数空间的投影。而螺旋线的叠加如果用一个形象的栗子来理解是什么呢？光波高中时我们就学过，自然光是由不同颜色的光叠加而成的，而最著名的实验就是牛顿师傅的三棱镜实验：所以其实我们在很早就接触到了光的频谱，只是并没有了解频谱更重要的意义。但不同的是，傅里叶变换出来的频谱不仅仅是可见光这样频率范围有限的叠加，而是频率从0到无穷所有频率的组合。这里，我们可以用两种方法来理解正弦波：第一种前面已经讲过了，就是螺旋线在实轴的投影。另一种需要借助欧拉公式的另一种形式去理解：将以上两式相加再除2，得到：这个式子可以怎么理解呢？我们刚才讲过，e^(it)可以理解为一条逆时针旋转的螺旋线，那么e^(-it)则可以理解为一条顺时针旋转的螺旋线。而cos(t)则是这两条旋转方向不同的螺旋线叠加的一半，因为这两条螺旋线的虚数部分相互抵消掉了！举个例子的话，就是极化方向不同的两束光波，磁场抵消，电场加倍。这里，逆时针旋转的我们称为正频率，而顺时针旋转的我们称为负频率（注意不是复频率）。好了，刚才我们已经看到了大海——连续的傅里叶变换频谱，现在想一想，连续的螺旋线会是什么样子：想象一下再往下翻：||||||||||||| 是不是很漂亮？你猜猜，这个图形在时域是什么样子？ 哈哈，是不是觉得被狠狠扇了一个耳光。数学就是这么一个把简单的问题搞得很复杂的东西。顺便说一句，那个像大海螺一样的图，为了方便观看，我仅仅展示了其中正频率的部分，负频率的部分没有显示出来。如果你认真去看，海螺图上的每一条螺旋线都是可以清楚的看到的，每一条螺旋线都有着不同的振幅（旋转半径），频率（旋转周期）以及相位。而将所有螺旋线连成平面，就是这幅海螺图了。好了，讲到这里，相信大家对傅里叶变换以及傅里叶级数都有了一个形象的理解了，我们最后用一张图来总结一下: 好了，傅里叶的故事终于讲完了，下面来讲讲我的故事：这篇文章第一次被写下来的地方你们绝对猜不到在哪，是在一张高数考试的卷子上。当时为了刷分，我重修了高数（上），但是后来时间紧压根没复习，所以我就抱着裸考的心态去了考场。但是到了考场我突然意识到，无论如何我都不会比上次考的更好了，所以干脆写一些自己对于数学的想法吧。于是用了一个小时左右的时间在试卷上洋洋洒洒写了本文的第一草稿。你们猜我的了多少分？6分没错，就是这个数字。而这6分的成绩是因为最后我实在无聊，把选择题全部填上了C，应该是中了两道，得到了这宝贵的6分。说真的，我很希望那张卷子还在，但是应该不太可能了。那么你们猜猜我第一次信号与系统考了多少分呢？45分没错，刚刚够参加补考的。但是我心一横没去考，决定重修。因为那个学期在忙其他事情，学习真的就抛在脑后了。但是我知道这是一门很重要的课，无论如何我要吃透它。说真的，信号与系统这门课几乎是大部分工科课程的基础，尤其是通信专业。在重修的过程中，我仔细分析了每一个公式，试图给这个公式以一个直观的理解。虽然我知道对于研究数学的人来说，这样的学习方法完全没有前途可言，因为随着概念愈加抽象，维度越来越高，这种图像或者模型理解法将完全丧失作用。但是对于一个工科生来说，足够了。后来来了德国，这边学校要求我重修信号与系统时，我彻底无语了。但是没办法，德国人有时对中国人就是有种藐视，觉得你的教育不靠谱。所以没办法，再来一遍吧。这次，我考了满分，而及格率只有一半。老实说，数学工具对于工科生和对于理科生来说，意义是完全不同的。工科生只要理解了，会用，会查，就足够了。但是很多高校却将这些重要的数学课程教给数学系的老师去教。这样就出现一个问题，数学老师讲得天花乱坠，又是推理又是证明，但是学生心里就只有一句话：学这货到底干嘛用的？缺少了目标的教育是彻底的失败。在开始学习一门数学工具的时候，学生完全不知道这个工具的作用，现实涵义。而教材上有只有晦涩难懂，定语就二十几个字的概念以及看了就眼晕的公式。能学出兴趣来就怪了！好在我很幸运，遇到了大连海事大学的吴楠老师。他的课全程来看是两条线索，一条从上而下，一条从下而上。先讲本门课程的意义，然后指出这门课程中会遇到哪样的问题，让学生知道自己学习的某种知识在现实中扮演的角色。然后再从基础讲起，梳理知识树，直到延伸到另一条线索中提出的问题，完美的衔接在一起！这样的教学模式，我想才是大学里应该出现的。最后，写给所有给我点赞并留言的同学。真的谢谢大家的支持，也很抱歉不能一一回复。因为知乎专栏的留言要逐次加载，为了看到最后一条要点很多次加载。当然我都坚持看完了，只是没办法一一回复。本文只是介绍了一种对傅里叶分析新颖的理解方法，对于求学，还是要踏踏实实弄清楚公式和概念，学习，真的没有捷径。但至少通过本文，我希望可以让这条漫长的路变得有意思一些。最后，祝大家都能在学习中找到乐趣。… 作 者：韩 昊知 乎：Heinrich微 博：@花生油工人知乎专栏：与时间无关的故事谨以此文献给大连海事大学的吴楠老师，柳晓鸣老师，王新年老师以及张晶泊老师。很喜欢这篇文章，关于傅里叶级数的解释本人是十分佩服的，分享给大家，也希望自己有朝一日能写出这样的作品。 以上是原作者所著原文。本文完","categories":[{"name":"搞专业","slug":"搞专业","permalink":"http://www.luheng.online/categories/搞专业/"}],"tags":[{"name":"傅里叶级数","slug":"傅里叶级数","permalink":"http://www.luheng.online/tags/傅里叶级数/"}]},{"title":"天下文章不负文人","slug":"天下文章不负文人","date":"2017-03-01T09:11:36.000Z","updated":"2017-12-30T15:59:26.028Z","comments":true,"path":"2017/03/01/天下文章不负文人/","link":"","permalink":"http://www.luheng.online/2017/03/01/天下文章不负文人/","excerpt":"惟古于词必己出,降而不能乃剽贼","text":"惟古于词必己出,降而不能乃剽贼 歌名：《抄抄》原著：大风刮过扒带：卡其漠【平纱落雁】填词：结风演唱：卿雲/KuRy颜酱后期：茶查叉PV：白砂【平纱落雁】海报：King 金玉满梦枕 醒时名起三春放眼锦绣丛拥 兀见白骨数根皆前世 被我生吞我今魂归来 来斩梁上某君昔年慕我颜色乘人不备夺我牙惠之吻认或不认？在座高朋知我名场久盛岂不自惜清高灵魂纵君画皮美名盈朱门知君原形唯故人在座高朋知我富有土滨岂识她这穷酸刁民我亦奇君买卖无本窃我三文 窃邻三文 西凑东拼时势造你 沐猴一尊车马喧她门 乱中误踏拥趸友与雀访我门 虽谓弊帚自珍问天网 几时能临暗唾尔苦主 化作春泥一痕育我妖红冶叶已是你三生修来之福份竟不感恩提刀向君 古有怒士杀人今日是也 刀笔开刃谢你牙惠喂我肥千斤我自皮厚如长城提刀向君 斩下窃羽一根寒号之鸟 速速惊弓拥趸丛中黯然过冬来年春时劫满又是天神自尊凉凉近事凉透一颗初心天下文章负尽文人岁岁年年桃花相似否浇以狗血满钵盆血肉皮囊本皆另属高明此君之流莫非鬼影料得明朝辉煌时分魇中应有同类缠身扒尽所窃见枯骨一尊 注：①土滨：率土之滨，谓先秦封建领主封地②沐猴：沐猴而冠，比喻虚有其表，形同傀儡，或是讥嘲为人愚鲁无知空有表面③寒号鸟：指童话中到处借人羽毛且不筑巢的寒号鸟④岁岁年年花相似：“年年岁岁花相似，岁岁年年人不同”，原作刘希夷。舅舅宋之问杀刘希夷，将此惊艳诗句据为己有 这首歌曲背后的故事来源于网络写手唐七公子抄袭大风刮过的作品，网友的愤慨之作。在一定程度上也影响我，著文章务必务实，转载必注明出处，把歌曲放在这里，警示之用。","categories":[{"name":"搞生活","slug":"搞生活","permalink":"http://www.luheng.online/categories/搞生活/"}],"tags":[{"name":"慎独","slug":"慎独","permalink":"http://www.luheng.online/tags/慎独/"}]},{"title":"计算机的硬件组成--综述","slug":"计算机组成-综述","date":"2017-02-28T06:24:59.000Z","updated":"2017-12-30T11:43:15.823Z","comments":true,"path":"2017/02/28/计算机组成-综述/","link":"","permalink":"http://www.luheng.online/2017/02/28/计算机组成-综述/","excerpt":"现在是人们常说得互联网时代，相信大家都认识计算机，也就是常说得电脑，那么计算机的定义到底是什么？计算机里面有什么？它们是如何工作的？这些问题后面会有更多的文章去解答，本文主要讲述计算机的定义、历史和组成。说一些大的概念，让大家对计算机有个大体上的认识，这是书写本文的主要目的。","text":"现在是人们常说得互联网时代，相信大家都认识计算机，也就是常说得电脑，那么计算机的定义到底是什么？计算机里面有什么？它们是如何工作的？这些问题后面会有更多的文章去解答，本文主要讲述计算机的定义、历史和组成。说一些大的概念，让大家对计算机有个大体上的认识，这是书写本文的主要目的。文章若有错误，欢迎大家在讨论区与我交流，及时斧正。 其实对于计算机，个人认为没什么规定的说法。我也不希望用一个定义去框死它，简单的说，计算机就是处理数据的机器，接收用户输入指令与数据，经过中央处理器的数据与逻辑单元运算处理后，以产生或存储成有用的信息。 根据这个说法，不难看出，只要有输入设备，处理器，输出设备，在输入数据后能产生有用信息的机器就可称为计算机。举个例子，用于加减乘除的计数器，手机，银行的取款机…这些都是计算机。 当然以上都是从计算机的简单定义上看待的，我们日常所达成的共识是个人电脑（pc）和笔记本电脑这一类机器称为计算机。但这都不妨碍我们学习它，为了方便，本文和之后的文章我都是以常见的个人电脑来作说明，其他的不拓展。 电子计算机历史了解计算机的历史有助于我们更好地认识它，而且这些有趣的历史也会为我们打开知识的大门。下面让我们看下关于它的历史。 1946年2月，第一台电子计算机ENIAC在美国加州问世，ENIAC用了18000个电子管和86000个其它电子元件，有两个教室那么大，运算速度却只有每秒300次各种运算或5000次加法，耗资100万美元以上。尽管ENIAC有许多不足之处，但它毕竟是计算机的始祖，揭开了计算机时代的序幕。 计算机的发展到目前为止共经历了四个时代，从1946年到1959年这段时期我们称之为“电子管计算机时代”。第一代计算机的内部元件使用的是电子管。由于一部计算机需要几千个电子管，每个电子管都会散发大量的热量，因此，如何散热是一个令人头痛的问题。电子管的寿命最长只有3000小时，计算机运行时常常发生由于电子管被烧坏而使计算机死机的现象。第一代计算机主要用于科学研究和工程计算。 从1960年到1964年，由于在计算机中采用了比电子管更先进的晶体管，所以我们将这段时期称为“晶体管计算机时代”。晶体管比电子管小得多，不需要暖机时间，消耗能量较少，处理更迅速、更可靠。第二代计算机的程序语言从机器语言发展到汇编语言。接着，高级语言FORTRAN语言和COBOL语言相继开发出来并被广泛使用。这时，开始使用磁盘和磁带作为辅助存储器。第二代计算机的体积和价格都下降了，使用的人也多起来了，计算机工业迅速发展。第二代计算机主要用于商业、大学教学和政府机关。 从1965年到1970年，集成电路被应用到计算机中来，因此这段时期被称为“中小规模集成电路计算机时代”。集成电路（Integrated Circuit，简称r）是做在晶片上的一个完整的电子电路，这个晶片比手指甲还小，却包含了几千个晶体管元件。第三代计算机的特点是体积更小、价格更低、可靠性更高、计算速度更快。第三代计算机的代表是IBM公司花了50亿美元开发的IBM 360系列。 从1971年到现在，被称之为“大规模集成电路计算机时代”。第四代计算机使用的元件依然是集成电路，不过，这种集成电路已经大大改善，它包含着几十万到上百万个晶体管，人们称之为大规模集成电路（LargeScale lntegrated Circuit，简称LSI）和超大规模集成电路（Very Large Scale lntegrated Circuit，简称VLSI）。1975年，美国1BM公司推出了个人计算机PC（PersonaI Computer），从此，人们对计算机不再陌生，计算机开始深入到人类生活的各个方面。 路漫漫其修远兮，计算机在诞生之前还有很多有趣的故事，有许多前人上下求索留下的历史痕迹，有兴趣的读者可以去了解，相信会有很多收获。 计算机硬件的组成单以计算机的外表，我们一般可以看到鼠标、键盘等输入设备；屏幕（触摸式除外）、音响等输出设备，打开机箱或者拆开笔记本后盖还可以看到计算机的其他组成部分。计算机器件可分为五大单元 1.输入单元：键盘、鼠标、手写板、触摸屏幕等2.输出单元：屏幕、音响、打印机等3.控制单元：主要用于协调各组件与单元的工作4.算术逻辑单元：主要负责程序运算和逻辑判断 注：（控制单元和算术逻辑单元都是CPU里面的）5.存储单元：内存条，硬盘等 图中的系统单元就是计算机主机内的主要组件，主要是CPU和内存，实线是数据的传输方向，由图中可以看出基本上数据都是经过内存再转出去的。特别要注意的是，CPU实际要处理的数据完全来自于内存，内存流出流进的是CPU的控制命令。关于数据的传输也有很多学问，这里先不展开说明吧，感兴趣可以在网上查找。 谈一谈CPUCPU就是中央处理器（Central Processing Unit）,是一个具有特定功能的芯片，里面含有微指令集。这些指令集的设计主要分为两大设计理念，因此也让CPU分成了两大种类,分别是精简指令集系统和复杂指令集系统。 精简指令集，是计算机中央处理器的一种设计模式，也被称为RISC(Reduced Instruction Set Computing的缩写)。这种设计思路对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。常用的精简指令集微处理器包括DECAlpha、ARC、ARM、AVR、MIPS、PA-RISC、PowerArchitecture(包括PowerPC)和SPARC等. 在应用上，很多人可能听过ARM架构，因为它估计是世界上使用范围最广的CPU。我们常用的手机、导航系统、路由器、交换机等，几乎都是使用ARM架构的CPU。其他架构，例如SPARC架构的计算机主要用于学术领域的大型工作站，还有AVR、MIPS等结构这里就不展开了，老实说，这个我不懂，很多知识都是查找后了解的，对此点评做不到。十分渴望有读者在评论区帮我完善，提点一二。 复杂指令集，也称为CISC指令集，英文名是CISC，（Complex Instruction Set Computing的缩写）。在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。其实它是英特尔(Intel)生产的x86系列（也就是IA-32架构）CPU及其兼容CPU，如AMD、VIA的。即使是现在新起的X86-64（也被称为AMD64）都是属于CISC的范畴。 其中x86架构的CPU最早是Intel生产出来的，就是我们常说的8086，后面Intel依此结构又开发了80286，80386，这一架构现在被大量用于个人计算机，所以个人计算机也常被称为x86的计算机。之后该架构的CPU从8位升级到16位、32位，直到2003年AMD公司对其进行修改，发展到现在的64位，有理由相信未来会发展到128位的，让我们期待吧。 多说一点，其实X86架构的CPU，内部不同指令集会导致CPU的性能不同，耗电能力，虚拟化能力都有差别，所以选购CPU时要多加考虑，说不定可以省点电费。当然，非专业相关的，单买CPU的也不会有几位，买组合好的计算机就没必要考虑太多，这些知识了解就好。 计算机分类来源：http://jingyan.baidu.com/article/495ba8411a1e7e38b20ede10.html 计算机及相关技术的迅速发展带动计算机类型也不断分化，形成了各种不向种类的计算机。按照计算机的结构原理可分为模拟计算机、数字计算机和混合式计算机。按计算机用途可分为专用计算机和通用计算机。较为普遍的是按照计算机的运算速度、字长、存储容量等综合性能指标，可分为巨型机、大型机、中型机、小型机、微型机。 高性能计算机高性能计算机也就是俗称的超级计算机，或者以前说的巨型机。目前国际上对高性能计算机的最为权威的评测是世界计算机排名(即TOP500)，通过测评的计算机是目前世界上运算速度和处理能力均堪称一流的计算机。我国生产的曙光4000A、联想深腾6800都进入了排行榜，这标志着我国高性能计算机的研究和发展取得了可喜的成绩。在2004年公布的全球高性能计算机TOP500诽行榜中，曙光4000A以11万亿次/s的峰值速度和80 610亿次/s Linpack计算值位列全球第十。至此，中国已成为继美国、日本之后的第3个进入世界前十位的高性能计算机应用的国家。目前曙光4000A落户上海超级计算中心 微型计算机大规模集成电路及超大规模集成电路的发展是微型计算机得以产生的前提。通过集触电路技术将计算机的核心部件运算器和控制器集成在一块大规模或放大规模集成电路芯片上，统称为中央处理器(CPU，Central Processing Unit)。中央处理器是微型计算机的核心部件，是微型计算机的心脏。目前微型计算机已广泛应用于办公、学习、娱乐等社会生活的方方面面，是发展最快、应用最为普及的计算机。我们日常使用的台式计算机、笔记本计算机、掌上型计算机等都是微型引算机。 工作站工作站是一种高档的微型计算机，通常配有高分辨率的大屏幕显尔器及容量很大的内存储器和外部存储器，主要面向专业应用领域，具备强大的数据运算与图形、图像处理能力。工作站主要是为满足工程设计、动画制作、科学研究、软件开发、金融管理、信息服务、模拟仿真等专业领域而设汁开发的同性能微型计算机。需要指出的是，这里所说的工作站不同于计算机网络系统中的工作站概念，计算机网络系统中的工作站仅是网络中的任何一台普通微型机或终端，只是网络中的任一用户节点。 服务器服务器是指在网络环境下为网上多个用户提供共享信息资源和各种服务的一种高性能计算机，在服务器上需要安装网络操作系统、网络协议和各种网络服务软件。服务器主要为网络用广提供文件、数据库、应用及通信方面的服务。 嵌入式计算机嵌入式计算机是指嵌入到对象体系中，实现对象体系智能化控制的专用计算机系统。嵌人式计算机系统是以应用为中心，以计算机技术为是础，并且软硬件可裁剪，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。它一般出以入式微处理器、外围硬件设备、嵌入式操作系统以及用户的应用程序等4个部分组成，用于实现对其他设备的控制、监视或管理等功能。例如，我们日常生活中使用的电冰箱、全自动洗衣机、空调、电饭煲、数码产品等都采用嵌入式计算机技术。 计算机上常用的单位数据单位计算机中数据单位的是bit(比特)。在计算机内部，数据都是以二进制的形式存储和运算的。 二进制数据中的一个位（bit）简写为b，音译为比特，是计算机存储数据的最小单位。一个二进制位只能表示0或1两种状态，要表示更多的信息，就要把多个位组合成一个整体，一般以8位二进制组成一个基本单位。 字节：计算机数据处理的最基本单位，主要以字节为单位解释信息。字节（Byte）简记为B，规定一个字节为8位，即1B=8bit。每个字节由8个二进制位组成。一般情况下，一个ASCII码占用一个字节，一个汉字国际码占用两个字节。 字：一个字通常由一个或若干个字节组成。字（Word）是计算机进行数据处理时，一次存取、加工和传送的数据长度。由于字长是计算机一次所能处理信息的实际位数，所以，它决定了计算机数据处理的速度，是衡量计算机性能的一个重要指标，字长越长，性能越好。 数据的换算关系1Byte=8bit，1KB=1024B，1MB=1024KB，1GB=1024MB。计算机型号不同，其字长是不同的，常用的字长有8、16、32和64位。一般情况下，IBM PC/XT的字长为8位，80286微机字长为16位，80386/80486微机字长为32位，Pentium系列微机字长为64位。 速度单位CPU的运算速度使用的是MHz或者是GHz之类的单位。而在网络传输上使用的是bit单位，因此常使用的是Mbit/s。举例：大家常听到的8M/1M网速，如果转换为文件容量的byte时，其实理论上最大传输值为：1MB/s / 125KB/s 的上传或下载速度。 由于单位的使用问题常常会产生一些误解，比如购买一个500G的硬盘，查看存储时发现只有大概466G的空间，这是因为一般硬盘的厂家会使用十进制为单位，500G=500x1000x1000x1000 bit的空间，转换成二进制500G≈466x1024x1024x1024 bit。所以只有大概466G的空间，商家没骗人，至于为什么商家用十进制计算，这与硬盘的容量计算有关，读者有兴趣可以查查。 参考文献鸟哥的Linux私房菜–基础学习篇个人计算机词条 (维基百科)谷歌学术的多篇文章（窗口一关就找不回来了QAQ）计算机的分类 （百度经验） 文中采用的数据或许有些是过时的了，不过我相信这些能帮我们了解知识，所以也采用了，此外，笔者才疏学浅，能力有限，本文只是我个人的拙见，仅供参考，欢迎大家指点。","categories":[{"name":"搞硬件","slug":"搞硬件","permalink":"http://www.luheng.online/categories/搞硬件/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"http://www.luheng.online/tags/硬件/"}]},{"title":"电热水器的构造和原理","slug":"电热水器的构造和原理","date":"2017-02-23T05:14:05.000Z","updated":"2018-01-07T10:39:59.789Z","comments":true,"path":"2017/02/23/电热水器的构造和原理/","link":"","permalink":"http://www.luheng.online/2017/02/23/电热水器的构造和原理/","excerpt":"之所以写这篇文章，都是怪宿舍那该死的电热水器频频罢工，而且原因不明，修理师傅来了又走，螺丝刀左旋右旋之间，总会换下一些小零件，情况一直不乐观，不过，似乎是被人伺候了，热水器也总是会服服帖帖的工作几日，现在貌似还在服役期间（毕竟修理师傅中午刚来过），可我总是担心它会变坏，毕竟一直都没让我安心，所以我决定考究一番，况且技多不压身，O(∩_∩)O~。","text":"之所以写这篇文章，都是怪宿舍那该死的电热水器频频罢工，而且原因不明，修理师傅来了又走，螺丝刀左旋右旋之间，总会换下一些小零件，情况一直不乐观，不过，似乎是被人伺候了，热水器也总是会服服帖帖的工作几日，现在貌似还在服役期间（毕竟修理师傅中午刚来过），可我总是担心它会变坏，毕竟一直都没让我安心，所以我决定考究一番，况且技多不压身，O(∩_∩)O~。 先给你们看看它的样子吧，就是这个讨厌的家伙下面便是我对它的研究，嗯哼（装作有学问的样子）。 电热水器的架构原理电热水器结构简图先看看外表的示意图 电热水器都是怎么工作的呢？ 工作原理 储水式电热水器贮满水通电后，电热水器内的电热管将电热水器内胆内的水加热，当加热到所设定的温度时电路自动断开，电热管停止加热，整机处于保温状态。当内胆内水温降低到某一温度时，电热管再次通电加热,这种状态循环往复，以便电热水器始终有热水可用。结构主要分为电路和水路两部分： 水路部分电热水器从第一次使用之后就是充满水了，之后进水通过安全阀单向（只能进水，不能出水）进入水箱内胆，下方进水口靠近水箱底部，其进水口上方有一挡板，使进入的冷水存在底部，防止冷水冲入上部影响热水水温，出水口在内胆上部，热水比冷水轻，在水的上部分，热水出水口也在此处，所以出水总是热的，要使热水流出，必须进入冷水，增加内胆内水压，热水才能被挤流出。关闭进水口，即使内胆存满热水也不会流出。流出的高温热水，通过调节混水阀，使之出水温度适合使用要求。热水能出来靠的是冷水进去时带来的水压，所以停水的时候即便内胆里充满水，里面的水也出不来，因为热水出水口在内胆上部。那冷水呢，停水了…(混水阀里的热水来自热水器，冷水是直接自来水管道的)。 电路部分电路的主要作用是对冷水加热至设定温度。电热水器的加热通过电热管来进行，温度的设定则通过调节温控器进行，电热水器将电能转换成热能，传给被加热的媒体（水），水达到预定温度时，温控器会自动断电，停止加热。一段时间后，当水温比设定温度下降5℃左右时，温控器会重新工作，继续恢复加热至设定温度，如此反复工作。原理图： 零部件介绍内胆内胆作为热水器的主要储水工具，它必须具备保温、耐压、不生锈、无水垢、不渗水的特性。决定一款热水器好坏的重要因素之一就是热水器的内胆，内胆的好坏直接决定了热水器的使用寿命，而且内胆一旦破损，那么热水器将很难修复，甚至直接报废，虽然热水器的品牌很多，内胆名称也五花八门，什么“金圭内胆”、“高釉包钢内胆”、“钛金内胆”、“不锈钢内胆”、“搪瓷内胆”、“钢制瓷釉内胆”、“金瓷内胆”等等，但实际上市面上常见的热水器内胆主要有不锈钢内胆和搪瓷内胆2种，所谓的钛金内胆、金圭内胆、石英瓷釉、蓝宝石等等，不过是在这两种主材外面镀上或加上稀有金属，换了个叫法而已。 类型 突出优点 缺点 不锈钢内胆 价格相对低廉 焊缝易损易漏水 晶硅内胆 强度高、不易生锈、寿命长 搪瓷内胆 不生锈、无水垢 易溶解、易腐蚀、易鱼鳞爆 钛金内胆 强度好、寿命长 金圭内胆 抗腐蚀、抗冲击、寿命长 . 镁棒镁棒主要作用在于保护电热棒，电加热棒在加热时容易与水里面的矿物质发生反应，从而减少加热棒的使用寿命。 工作原理：利用的是阴极保护法，由于镁的活性大于加热棒的铁或铜，因此通过镁棒的作用，使水里面的矿物质先与镁棒反应。镁是电化学序列中电位较低的金属，生理上无毒。因此，用来制成镁棒保护内胆非常理想。镁棒的大小直接关系到保护内胆时间的长短和保护效果的大小，镁棒越大，保护效果越好，保护时间越长。 防电墙利用了水本身所具有的电阻（国标规定自来水在15℃时电阻率应大于1300Ω），通过对热水器内通水管材质的选择（绝缘材料），管径和距离的确定形成“隔电墙”。当电热水器通电工作时，加热内胆的水即使有电，也会在通过“隔电墙”时被水本身的电阻衰减掉而达到将电隔离的目的，使热水器进出水两端达到几乎为零的电压和0.02mA/kw以下的极微弱电流。 加热管电能→热能转化装置，主要用它来对水进行加热（类似热得快），其功率为1500W-3000W，主要由发热电阻丝，铜管或不锈钢管，导热绝缘介质氧化镁和接线端子构成。当通电时，电流使发热电阻丝发热，热量通过电加热器将储在内胆的水加热，电热管由三层构成，最里面为电阻丝，中间为耐高温绝缘氧化镁粉，外层为不锈钢管（英格莱800金属管能耐受1357-1385C高温） 。电阻丝为直接发热元件，耐高温绝缘镁粉起到在高温下绝缘作用，以保证电热管的安全性。 控温器现用控温器均为液体膨胀式结构。利用液体有热胀冷缩的特性，控温器将特殊液体密封在探管和毛细管组成的密封腔中，探管插到待测温部位，当该处温度上升时探管内液体膨胀，并沿毛细管移动至末端，膨胀的液体使膜盒变型后推动触点，使电路断开，停止加热。 调节控温器旋钮，也就是调节将触点断开的位移量，而此位移量与感测的温度成特定比例。 当温度下降后，膨胀后的液体会逐渐缩小体积，触点又回复到导通状态，发热管重新开始加热，这就是控温器控制水温的原理。当内胆的温度达到设定值时，液态受热膨胀流过毛细管顶起杠杆板，金属片自然弹起，断开两极，停止加热。当水温下降到设定温度的5℃左右时，液态冷缩，杠杆板自动回弹并压下弹簧片，电路重新闭合，开始加热，实现保温功能。 超温保护器（热断路器）原理是当内胆水温达到88℃或91℃时，金属片受热变形向上弹，顶起绝缘顶杆，断开两极实现防超温保护。当双极断开需复位时，必须手动按下手动复位键，并用万用表测量两极是否相通。 漏电保护插头开关原理是利用漏电开关内部装置，当电热水器有漏电或负载电流大过额定电流时会自动跳闸，切断电源，避免事故发生。 写在后面的话关于电热水器的构造原理在网上查询学习后，只能说是有所了解，不敢对此再有更多的讨论，科学与生活息息相关，这次算是为洗个热水澡操碎了心吧，本章完。 关于本文：相关资料主要是从网上各个地方摘录下来的，来源不好注明出处，如有侵犯，请与我联系。","categories":[{"name":"搞生活","slug":"搞生活","permalink":"http://www.luheng.online/categories/搞生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.luheng.online/tags/生活/"}]},{"title":"单片机概述","slug":"单片机概述","date":"2017-02-20T08:17:36.000Z","updated":"2017-12-30T11:42:26.327Z","comments":true,"path":"2017/02/20/单片机概述/","link":"","permalink":"http://www.luheng.online/2017/02/20/单片机概述/","excerpt":"现在写作的笔者正在读大二，关于单片机，由于专业相关，我无可避免的与之相遇了，期待这是一场美丽的邂逅。所谓工欲善其事，必先利其器，来来回回看了不少东西，写点东西记录自己所学的知识，后期还会有更多相关的文章。嗯，就这样。","text":"现在写作的笔者正在读大二，关于单片机，由于专业相关，我无可避免的与之相遇了，期待这是一场美丽的邂逅。所谓工欲善其事，必先利其器，来来回回看了不少东西，写点东西记录自己所学的知识，后期还会有更多相关的文章。嗯，就这样。欢迎大家在评论区与我交流，如有错误，欢迎斧正。 什么是单片机既然要学习它，肯定要了解它。 专业语言上讲： 单片机，全称单片微型计算机（英语：single-chip microcomputer），又称微控制器（microcontroller），是把中央处理器、存储器、定时/计数器（timer/counter）、各种输入输出接口等都集成在一块集成电路芯片上的微型计算机。（来源：维基百科） 笔者首次看完这一段话的第一感受就是，这…好厉害的样子，然而表示依旧一脸懵逼，什么中央处理器、存储器、定时/计数器都不是很懂啦，这都什么鬼啊。相信初学者很多也会有这些问题，后面会写一些相关得博客去介绍计算机结构，这里不展开解释。其实，由于我们是使用者，所以我们只需知道它是块集成芯片，要使用编程的方式控制这块芯片的引脚，让它在不同的时间段内输出不同的电平，继而控制与引脚相连的外围电路，局限于使用，相信是足够的，就像用一样东西，能看懂它的说明书（数据手册），了解它是如何工作得就能使用了。关于单片机个人觉得在于看懂数据手册会使用是关键，至于它的内部原理有一定了解即可，这真不是我懒，因为复杂的芯片逻辑门数可能达到几万，甚至几十万、几百万，要了解内部结构再使用的话，会崩溃的。 单片机的最大优点是体积小，可放在仪表内部，但存储量小，输入输出接口简单，功能较低。由于其发展非常迅速，旧的单片机的定义已不能满足，所以在很多应用场合被称为范围更广的微控制器；由于单片机微电脑常用于当控制器故又名single chip microcontroller。此外，单芯片是台湾对单片机的称呼；中国大陆主要采用“单片机”的称呼，英文缩写为MCU。 单片机长什么样现在来瞅瞅… 它的样子是酱样大多数是酱样还有很多种样子，这是因为：由于采用的封装方式不同，单片机有多种外表，至于封装形式，有：123456DIP(Dual In-line Package)双列直插式封装PLCC(Plastic Leaded Chip Carrier)带引线的塑料芯片封装QFP(Quad Flat Package)塑料方形扁平式封装PFP(Plastic Flat Package)塑料扁平式组件式封装PGA(Pin Grid Array package)针插网格阵列封装BGA(Ball Grid Array package)球栅阵列封装 每一种封装形式都有各自的特点，适用不同的场合，对此感兴趣就自行查看资料吧，这个我也不是很懂，不敢妄言。 单片机的用途123456工业自动化。如数据采集、测控技术。只能仪器仪表。如数字示波器、数字信号源、数字万用表、感应电流表等。消费电子产品。如冰箱、空调、电视机、汽车电子设备等。通信方面。如调制解调器、程控交换技术、手机等。武器装备。导弹、鱼雷智导、智能武器等。... 上面的说法可能过于笼统，它具体应用在哪，举个例子：电磁炉控制火候的面板下面便是集成了单片机的板子，空调的红外遥控器，电子手表…真的在生活中无处不在，只是我们不了解，不熟悉罢了。 相关的学习网址单片机教程网CSDN我要自学网电子工程世界 参考文献单片机原理及应用 第三版（电子工业出版社）新概念 51单片机C语言——入门、提高、开发、拓展全攻略（郭天祥） ヽ(￣ω￣(￣ω￣〃)ゝ一起努力学习吧。","categories":[{"name":"搞硬件","slug":"搞硬件","permalink":"http://www.luheng.online/categories/搞硬件/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://www.luheng.online/tags/单片机/"}]},{"title":"markdown的基本使用","slug":"markdown的基本使用","date":"2017-02-19T09:28:15.000Z","updated":"2017-12-31T08:07:12.676Z","comments":true,"path":"2017/02/19/markdown的基本使用/","link":"","permalink":"http://www.luheng.online/2017/02/19/markdown的基本使用/","excerpt":"关于markdown的简介博主在这里不再赘述啦，如果想了解更多，可以看看下列的链接。 创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 下面举一些简单的例子","text":"关于markdown的简介博主在这里不再赘述啦，如果想了解更多，可以看看下列的链接。 创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 下面举一些简单的例子 标题标题是每篇文章必备而且最常用的格式。在Markdown中，如果想将一段文字定义为标题，只需要在这段文字前面加上#，再在 # 后加一个空格即可。还可增加二、三、四、五、六级标题，总共六级，只需要增加 # ，增加一个 # ，标题字号相应降低一级。如图： 列表列表格式也很常用，它可以让你的文稿变得井井有条。在Markdown中，你只需要在文字前面加上 - 就可以了；如果你希望是有序列表，在文字前面加上 1. 2. 3. 即可。 注：-、1.和文字之间要保留一个字符的空格。 引用如果你需要在文稿中引用一段别处的句子，那么就要用到「引用」格式。在引用文字前加上 &gt; 并与文字保留一个字符的空格，即可。12引用：&gt;Across the Great Wall we can reach every corner in the world. Across the Great Wall we can reach every corner in the world. 粗体和斜体Markdown 的粗体和斜体也非常简单：用两个 * 包含一段文本就是粗体的语法；用一个 * 包含一段文本就是斜体的语法。 链接与图片链接：在 Markdown 中，插入链接1[显示文本] (链接地址) 图片：在 Markdown 中，插入图片只需要使用1! [显示文本] (图片链接地址)即可。 注：插入图片的语法和链接的语法很像，只是前面多了一个 ！ 分割线分割线的语法只需要另起一行，连续输入三个星号 * 即可分割两段文字内容。如图： 表格当你需要在Markdown文稿中键入表格12345 | Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 效果 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 待办和清单待办事项和清单在日常工作、生活中经常被使用。在Markdown中，你只需要在待办的事项文本或者清单文本前加上- [ ]、- [x]即可。 表示未完成，- [x] 表示已完成。注：键入字符与字符之间都要保留一个字符的空格。具体呈现如下： 流程图在Markdown中，一段流程图语法以 “开头，以 “ 结尾。在 “` 后另起一行，书写graph XX，用以确定将要绘制的流程图及其类型（XX表示流程图类型）。流程图分为竖向和横向两大类，竖向包括自上而下和自下而上两种顺序，横向包括从右到左和从左到右两种顺序。其对应语法分别为：graph TB/graph BT/graph RL/graph LR。TB - top bottom（自上而下）BT - bottom top（自下而上）RL - right left（从右到左）LR - left right（从左到右）简单示例如图：来学习一个具体案例：仔细研究上述案例，会发现，++我们可以通过调整语法来调整流程图的框线、连接线，不同条件能导向不同结果++。①对框线形状的调整，如: ②对箭头的调整，如: 只要充分掌握该语法，再复杂的流程图也完全能用Markdown书写！更详细的流程图语法，可参见：http://knsv.github.io/mermaid/#flowcharts-basic-syntax 甘特图我们在工作中用甘特图作计划进度表、项目进度表再合适不过了。以如下甘特图为例说明:与流程图一样，Markdown中，甘特图的语法也是以 “开头，以 “ 结尾。在 “` 后另起一行，书写 gantt ，用以确定将要绘制的是甘特图。标题的书写语法如下：dateFormat YYYY-MM-DD规定了时间轴，title （标题文本）表示甘特图标题。如需按项目进行划分，需键入section，空一个字符，再输入项目名称的文本（一个section和另一个section之间要空行）。每个大项目将拆解为若干个小任务，只需在section之后另起一行，直接输入小项目名称即可。更详细的甘特图语法，参见：http://knsv.github.io/mermaid/#styling39 代码折叠.testButton { color:black;font-size:12px;padding-top:10px;padding-bottom:10px;padding-left:25px;padding-right:25px;border-width:;border-color:white;border-style:;border-radius:10px;background-color:#f3f3f3;}.testButton:hover{color:white;background-color:#0684bd;border-color:#87daff;} 点击显\\隐代码 123456789&lt;style&gt;.testButton &#123; color:black;font-size:12px;padding-top:10px;padding-bottom:10px;padding-left:25px;padding-right:25px;border-width:;border-color:white;border-style:;border-radius:10px;background-color:#f3f3f3;&#125;.testButton:hover&#123;color:white;background-color:#0684bd;border-color:#87daff;&#125;&lt;/style&gt;&lt;button class=&quot;testButton&quot; onclick=&quot;document.all.child1.style.display=(document.all.child1.style.display ==&apos;none&apos;)?&apos;&apos;:&apos;none&apos;&quot;&gt;点击显\\隐代码&lt;/button&gt;&lt;div id=&quot;child1&quot; style=&quot;display:none&quot;&gt; 此处放代码&lt;/div&gt; 参考文献http://note.youdao.com/iyoudao/?p=2411&amp;vendor=unsilent14","categories":[{"name":"搞软件","slug":"搞软件","permalink":"http://www.luheng.online/categories/搞软件/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://www.luheng.online/tags/markdown/"}]},{"title":"hexo+github搭建博客教程","slug":"hexo-github搭建博客教程","date":"2017-01-28T06:07:28.000Z","updated":"2018-01-02T06:36:15.813Z","comments":true,"path":"2017/01/28/hexo-github搭建博客教程/","link":"","permalink":"http://www.luheng.online/2017/01/28/hexo-github搭建博客教程/","excerpt":"前言：博主一开始想拥有一个专属域名的网站，于是便有了后来创建博客的折腾路程，此贴是用来总结下搭建博客的过程，所以写得比较细（其实是怕自己以后忘了），希望对大家搭建博客有所帮助。","text":"前言：博主一开始想拥有一个专属域名的网站，于是便有了后来创建博客的折腾路程，此贴是用来总结下搭建博客的过程，所以写得比较细（其实是怕自己以后忘了），希望对大家搭建博客有所帮助。 准备阶段软件准备：git；node.js；sublime（选用，最好有） git（需翻墙）：如果你的电脑是window 64位可以点击此处下载 把本地的 hexo 代码提交到 github 上去。 node.js： hexo 运行环境，用来创建 hexo 博客框架。 sublime（选用）: 用于修改博客界面 git安装教程，node.js和sublime安装比较简单，这里便不再赘述。 git指令介绍： hexo g #完整命令为 hexo generate,用于生成静态文件 hexo s #完整命令为 hexo server,用于启动服务器，主要用来本地预览 hexo d #完整命令为 hexo deploy,用于将本地文件发布到github上 hexo n #完整命令为 hexo new,用于新建一篇文章 hexo clean #清除生成的文件 git clone:将远程仓库复制到本地 git init:新建一个仓库 git pull：抓取远程仓库所有分支更新并合并到本地 git commit:提交你的修改 安装方法：Hexo 是一个快速、简洁且高效的博客框架，我们首先要把这个框架搭起来，方法很简单：任意位置右键看到Git Bash Here，点击。 打开git的命令窗口后，输入： npm install -g hexo 如果命令无法运行，可以尝试更换taobao的npm源: npm config set registry “https://registry.npm.taobao.org“ 安装完毕后，在自己喜欢的地方建立一个hexo文件（如E:\\blog\\hexo）,直接进入E:\\blog\\hexo点击鼠标右键执行Git Bash Here，然后在工作窗口执行以下命令： hexo init npm install hexo便安装完毕，在E:\\blog\\hexo内的目录如下： 本地预览，可以简单的查看一下效果，输入命令： hexo s 然后用浏览器访问http://localhost:4000，应该能看到默认的效果了（自带主题landscape）。 之后便是部署到github上，这样才能在网上访问，而不是像现在在本地预览 申请一个github账号教程传送门 建立项目仓库：注册完登陆后，创建一个我们自己的Github Pages项目。点击New repository。 具体操作要点如下图 创建好后便可以访问了，域名为：username.github.io（可是没有内容），我们需要配置SSH密钥，在本地上传点内容给它。 配置SSH密钥方法：配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。 第一次申请账号肯定不会有SSH密钥的，如果你忘记了自己是否已经添加了密钥，也可以打开git bash输入： cd ~/. ssh 检查你本机用户home目录下是否存在.ssh目录。 如果已经添加则不必重复添加,否则需要执行下列步骤添加密钥： ①创建一对新的SSH密钥(keys) ssh-keygen -t rsa -C “your_email@example.com” 这会根据你提供的邮箱地址，创建一个密钥，你的邮箱也会有相应的邮箱提醒 在git的命令窗口则会产生下列的回复 Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 直接回车键，密钥就会存放在命令窗口提示的路径中，如:(/c/Users/you/.ssh/id_rsa）。 根据路径，打开密钥存放的文件夹，找到id_rsa文件，打开它，先复制里面的内容，那就是你的密钥（下面的配置会用到它） 而在你的命令窗口，接下来就会有提示，根据提示，你需要输入密码和确认密码（其实有没有密码也无所谓，毕竟没有密码就是最好的密码，手动滑稽）。 相应提示如下： Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 输入完之后，命令窗口便会有类似这样的信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 之后便是在github网页上操作打开官网，进入你的Account Settings. 点击settings。 将密钥复制到窗口中 之后SSH的密钥便设置完成。 测试是否配置成功：输入下列命令 ssh -T git@github.com 若出现 The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 回复yes即可。会看到 Hi cnfeat! You’ve successfully authenticated, but GitHub does not provide shell access. 完善个人信息： $ git config –global user.name “cnfeat”//用户名 $ git config –global user.email “cnfeat@gmail.com”//填写自己的邮箱 现在恭喜你，你的SSH已经配置成功,本地已与github成功连接。 如有问题，请参考GitHub Help - Generating SSH Keys Error: Permission denied (publickey) 既然连接好了，我们就要传点东西给它才好，下面是教程。 将本地的Hexo文件更新到Github的库中：登录Github打开自己的项目 username.github.io; 之后找到clone or download并点击： 复制地址 打开你一开始创建的Hexo文件夹（如F:\\Blog\\Hexo），用sublime(没有的话，用记事本也行)打开文件夹下的_config.yml文件 在里面修改配置并保存在hexo下执行 hexo g hexo d 第一次hexo d可能会报错： ERROR Deployer not found:git 需要安装一下hexo-deployer-git这个插件： npm install hexo-deployer-git –save 这时候输入自己的博客域名，地址是 username.github.io（我的是sirlh.github.io） 在网页上就可以看到自己的博客了 另外还有一些资料： https://www.jianshu.com/p/efbeddc5eb19 http://blog.csdn.net/gdutxiaoxu/article/details/53576018 注：部分图片来自http://www.jianshu.com/p/0b33006a48e6,侵删。","categories":[{"name":"搞软件","slug":"搞软件","permalink":"http://www.luheng.online/categories/搞软件/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.luheng.online/tags/hexo/"}]}]}